# SOME DESCRIPTIVE TITLE.
# Copyright (C) - The MicroPython Documentation is Copyright © 2014-2022,
# Damien P. George, Paul Sokolovsky, and contributors
# This file is distributed under the same license as the MicroPython
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: MicroPython 1.18\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-10 14:42+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../reference/repl.rst:2
msgid "The MicroPython Interactive Interpreter Mode (aka REPL)"
msgstr "MicroPython 交互式解释器模式 （又名 REPL）"

#: ../../reference/repl.rst:4
msgid ""
"This section covers some characteristics of the MicroPython Interactive "
"Interpreter Mode. A commonly used term for this is REPL (read-eval-print-"
"loop) which will be used to refer to this interactive prompt."
msgstr ""
"本节介绍 MicroPython 交互式解释器模式的一些特性。"
"一个常用的术语是 REPL (read-eval-print-loop)，它将用来指代这个交互式提示。"

#: ../../reference/repl.rst:9
msgid "Auto-indent"
msgstr "自动缩进"

#: ../../reference/repl.rst:11
msgid ""
"When typing python statements which end in a colon (for example if, for, "
"while) then the prompt will change to three dots (...) and the cursor "
"will be indented by 4 spaces. When you press return, the next line will "
"continue at the same level of indentation for regular statements or an "
"additional level of indentation where appropriate. If you press the "
"backspace key then it will undo one level of indentation."
msgstr ""
"当输入以冒号结尾的 python 语句时（例如 if、for、while），"
"提示符将变为三个点（...），光标将缩进 4 个空格。"
"当你按下回车键时，下一行将在相同缩进或适当的附加缩进后继续。"
"如果你按退格键，那么它将撤消一级缩进。"

#: ../../reference/repl.rst:18
msgid ""
"If your cursor is all the way back at the beginning, pressing RETURN will"
" then execute the code that you've entered. The following shows what "
"you'd see after entering a for statement (the underscore shows where the "
"cursor winds up):"
msgstr ""
"如果你的光标一直回到开头，则按 RETURN （回车）将执行您输入的代码。"
"下方显示了输入 for 语句后你会看到的内容（下划线表示光标结束的位置）："

#: ../../reference/repl.rst:25
msgid ""
"If you then enter an if statement, an additional level of indentation "
"will be provided:"
msgstr ""
"如果你接着输入 if 语句，将会出现额外的缩进："

#: ../../reference/repl.rst:32
msgid "Now enter ``break`` followed by RETURN and press BACKSPACE:"
msgstr "现在输入 ``break`` ，然后按 RETURN （回车）并按 BACKSPACE （退格）"

#: ../../reference/repl.rst:39
msgid ""
"Finally type ``print(i)``, press RETURN, press BACKSPACE and press RETURN"
" again:"
msgstr ""
"最后键入 ``print(i)``，按 RETURN （回车），按 BACKSPACE （退格）然后再按 RETURN （回车）："

#: ../../reference/repl.rst:52
msgid ""
"Auto-indent won't be applied if the previous two lines were all spaces.  "
"This means that you can finish entering a compound statement by pressing "
"RETURN twice, and then a third press will finish and execute."
msgstr ""
"如果前两行都是空格，则不会应用自动缩进。"
"这意味着你可以通过按两次 RETURN （回车）结束输入复合语句，然后按第三次时将结束输入并执行。"

#: ../../reference/repl.rst:57
msgid "Auto-completion"
msgstr "自动补全"

#: ../../reference/repl.rst:59
msgid ""
"While typing a command at the REPL, if the line typed so far corresponds "
"to the beginning of the name of something, then pressing TAB will show "
"possible things that could be entered. For example, first import the "
"machine module by entering ``import machine`` and pressing RETURN. Then "
"type ``m`` and press TAB and it should expand to ``machine``. Enter a dot"
" ``.`` and press TAB again. You should see something like:"
msgstr ""
"在 REPL 中键入命令时，如果到当前行输入的内容能对应于某些名称的开头，"
"则按 TAB 将显示可能输入的内容。例如，首先通过输入 ``import machine`` 并按 RETURN （回车）来导入机器模块。"
"然后键入 ``m`` 并按 TAB，它应该能补全为 `machine` 。此时输入一个句点 ``.`` 并再次按 TAB。"
"你应该会看到如下内容："

#: ../../reference/repl.rst:72
msgid ""
"The word will be expanded as much as possible until multiple "
"possibilities exist. For example, type ``machine.Pin.AF3`` and press TAB "
"and it will expand to ``machine.Pin.AF3_TIM``. Pressing TAB a second time"
" will show the possible expansions:"
msgstr ""
"输入的词将尽可能地补全，直到存在多种可补全的选项而导致无法默认选择时。"
"例如，输入 ``machine.Pin.AF3`` 并按 TAB，"
"它将补全为 ``machine.Pin.AF3_TIM``。再次按 TAB 将显示可能的扩展："

#: ../../reference/repl.rst:82
msgid "Interrupting a running program"
msgstr "中断正在运行的程序"

#: ../../reference/repl.rst:84
msgid ""
"You can interrupt a running program by pressing Ctrl-C. This will raise a"
" KeyboardInterrupt which will bring you back to the REPL, providing your "
"program doesn't intercept the KeyboardInterrupt exception."
msgstr ""
"你可以通过按 Ctrl-C 来中断正在运行的程序。"
"这将引发一个 KeyboardInterrupt ，"
"并它会带你回到 REPL，前提是你的程序不会捕获 KeyboardInterrupt 异常。"

#: ../../reference/repl.rst:88
msgid "For example:"
msgstr "例如："

#: ../../reference/repl.rst:107
msgid "Paste mode"
msgstr "粘贴模式"

#: ../../reference/repl.rst:109
msgid ""
"If you want to paste some code into your terminal window, the auto-indent"
" feature will mess things up. For example, if you had the following "
"python code: ::"
msgstr ""
"如果你想将一些代码粘贴到终端窗口中，自动缩进功能会表现得很糟糕。"
"例如，如果你有以下 python 代码："

#: ../../reference/repl.rst:117
msgid ""
"and you try to paste this into the normal REPL, then you will see "
"something like this:"
msgstr ""
"然后你尝试将它粘贴到正常的 REPL 中，然后你会看到如下内容："

#: ../../reference/repl.rst:129
msgid ""
"If you press Ctrl-E, then you will enter paste mode, which essentially "
"turns off the auto-indent feature, and changes the prompt from ``>>>`` to"
" ``===``. For example:"
msgstr ""
"如果你按下 Ctrl-E，那么你将进入粘贴模式，这实际上会关闭自动缩进功能，"
"并将前缀的提示从 更改 ``>>>`` 为 ``===``。例如："

#: ../../reference/repl.rst:143
msgid ""
"Paste Mode allows blank lines to be pasted. The pasted text is compiled "
"as if it were a file. Pressing Ctrl-D exits paste mode and initiates the "
"compilation."
msgstr ""
"在粘贴模式中，粘贴空白行也是。粘贴的文本实际上作为文件来编译。"
"按下 Ctrl-D 退出粘贴模式时，则启动编译。"

#: ../../reference/repl.rst:147
msgid "Soft reset"
msgstr "软复位"

#: ../../reference/repl.rst:149
msgid ""
"A soft reset will reset the python interpreter, but tries not to reset "
"the method by which you're connected to the MicroPython board (USB-"
"serial, or Wifi)."
msgstr ""
"软复位将重置 python 解释器，但不会重置你连接到 MicroPython 板的方式（例如 USB 串口或 Wifi）。"

#: ../../reference/repl.rst:152
msgid ""
"You can perform a soft reset from the REPL by pressing Ctrl-D, or from "
"your python code by executing: ::"
msgstr ""
"你可以通过按 Ctrl-D 从 REPL 执行软复位，或者通过从你的 python 代码执行："

#: ../../reference/repl.rst:157
msgid ""
"For example, if you reset your MicroPython board, and you execute a dir()"
" command, you'd see something like this:"
msgstr ""
"例如，如果你重置 MicroPython 板，并执行 dir() 命令，你会看到如下内容："

#: ../../reference/repl.rst:163
msgid "Now create some variables and repeat the dir() command:"
msgstr "现在创建一些变量再重复 dir() 命令："

#: ../../reference/repl.rst:172
msgid ""
"Now if you enter Ctrl-D, and repeat the dir() command, you'll see that "
"your variables no longer exist:"
msgstr ""
"现在，如果你输入 Ctrl-D，并重复执行 dir() 命令，你会看到你的变量已经不再存在："

#: ../../reference/repl.rst:186
msgid "The special variable _ (underscore)"
msgstr "特殊变量 _ （下划线）"

#: ../../reference/repl.rst:188
msgid ""
"When you use the REPL, you may perform computations and see the results. "
"MicroPython stores the results of the previous statement in the variable "
"_ (underscore). So you can use the underscore to save the result in a "
"variable. For example:"
msgstr ""
"当你使用 REPL 时，你可以执行计算并查看结果。"
"MicroPython 将前一条语句的结果存储在变量 _（下划线）中。"
"因此，你可以使用下划线将结果保存在变量中。例如："

#: ../../reference/repl.rst:200
msgid "Raw mode and raw-paste mode"
msgstr "Raw 模式和 Raw 粘贴模式"

#: ../../reference/repl.rst:202
msgid ""
"Raw mode (also called raw REPL) is not something that a person would "
"normally use. It is intended for programmatic use and essentially behaves"
" like paste mode with echo turned off, and with optional flow control."
msgstr ""
"Raw 模式（也称为 Raw REPL），它并不是人们通常会使用的东西。"
"它旨在用于编写程序，本质上类似于粘贴模式，关闭了输出，并且拥有可选的流控制。"

#: ../../reference/repl.rst:206
msgid ""
"Raw mode is entered using Ctrl-A. You then send your python code, "
"followed by a Ctrl-D. The Ctrl-D will be acknowledged by 'OK' and then "
"the python code will be compiled and executed. Any output (or errors) "
"will be sent back. Entering Ctrl-B will leave raw mode and return the the"
" regular (aka friendly) REPL."
msgstr ""
"使用 Ctrl-A 即可进入 Raw 模式。"
"然后发送你的 python 代码，然后按下 Ctrl-D。"
"Ctrl-D 代表 'OK' 确认，接着 python 代码将被编译和执行。"
"任何输出（或错误）都将被发回。"
"按下 Ctrl-B 即可离开原始模式并返回常规（又名友好）的 REPL。"

#: ../../reference/repl.rst:211
msgid ""
"Raw-paste mode is an additional mode within the raw REPL that includes "
"flow control, and which compiles code as it receives it. This makes it "
"more robust for high-speed transfer of code into the device, and it also "
"uses less RAM when receiving because it does not need to store a verbatim"
" copy of the code before compiling (unlike standard raw mode)."
msgstr ""
"Raw 粘贴模式是 Raw REPL 中的一种附加模式，"
"它包括流控制，并在收到代码时就对其进行编译。"
"这使得它在将代码高速传输到设备时更加健壮，"
"并且在接收时也使用更少的 RAM，"
"因为它不需要在编译之前逐字存储代码的副本（与标准 raw 模式不同）"

#: ../../reference/repl.rst:217
msgid "Raw-paste mode uses the following protocol:"
msgstr "Raw 粘贴模式使用以下协议："

#: ../../reference/repl.rst:219
msgid "Enter raw REPL as usual via ctrl-A."
msgstr "和一般情况一样通过 ctrl-A 输入 Raw REPL"

#: ../../reference/repl.rst:221
msgid "Write 3 bytes: ``b\"\\x05A\\x01\"`` (ie ctrl-E then \"A\" then ctrl-A)."
msgstr "写入 3 个字节： ``（b\"\\x05A\\x01\"`` 即 ctrl-E，然后是 \"A\"，在然后是 ctrl-A）。"

#: ../../reference/repl.rst:223
msgid "Read 2 bytes to determine if the device entered raw-paste mode:"
msgstr "读取 2 个字节以确定设备是否进入 Raw 粘贴模式："

#: ../../reference/repl.rst:225
msgid ""
"If the result is ``b\"R\\x00\"`` then the device understands the command "
"but doesn't support raw paste."
msgstr "如果结果是 ``b\"R\\x00\"`` ，则说明设备理解命令但不支持 Raw 粘贴模式。"

#: ../../reference/repl.rst:228
msgid ""
"If the result is ``b\"R\\x01\"`` then the device does support raw paste "
"and has entered this mode."
msgstr "如果结果是 ``b\"R\\x01\"`` ，则说明设备确实支持 Raw 粘贴并已进入此模式。"

#: ../../reference/repl.rst:231
msgid ""
"Otherwise the result should be ``b\"ra\"`` and the device doesn't support"
" raw paste and the string ``b\"w REPL; CTRL-B to exit\\r\\n>\"`` should "
"be read and discarded."
msgstr ""
"其他情况下，结果应该是 ``b\"ra\"`` 且代表设备不支持 Raw 粘贴；"
"然后你将看到字符串``b\"w REPL; CTRL-B to exit\\r\\n>\"`` ，并放弃当前操作。"

#: ../../reference/repl.rst:235
msgid ""
"If the device is in raw-paste mode then continue, otherwise fallback to "
"standard raw mode."
msgstr ""
"如果设备处于 Raw 粘贴模式，则继续，否则回退到标准 Raw 模式。"

#: ../../reference/repl.rst:238
msgid ""
"Read 2 bytes, this is the flow control window-size-increment (in bytes) "
"stored as a 16-bit unsigned little endian integer.  The initial value for"
" the remaining-window-size variable should be set to this number."
msgstr ""
"读取 2 个字节，这是存储为 16 位无符号小端整数的流控制窗口增量大小（以字节为单位）。"
"剩余窗口大小变量的初始值应设置为此数字。"

#: ../../reference/repl.rst:242
msgid "Write out the code to the device:"
msgstr "将代码写入设备"

#: ../../reference/repl.rst:244
msgid ""
"While there are bytes to send, write up to the remaining-window-size "
"worth of bytes, and decrease the remaining-window-size by the number of "
"bytes written."
msgstr ""
"当有字节要发送时，写入剩余窗口大小的字节，并将剩余窗口大小减少写入的字节数。"

#: ../../reference/repl.rst:248
msgid ""
"If the remaining-window-size is 0, or there is a byte waiting to read, "
"read 1 byte.  If this byte is ``b\"\\x01\"`` then increase the remaining-"
"window-size by the window-size-increment from step 5.  If this byte is "
"``b\"\\x04\"`` then the device wants to end the data reception, and "
"``b\"\\x04\"`` should be written to the device and no more code sent "
"after that.  (Note: if there is a byte waiting to be read from the device"
" then it does not need to be read and acted upon immediately, the device "
"will continue to consume incoming bytes as long as reamining-window-size "
"is greater than 0.)"
msgstr ""
"如果剩余窗口大小等于 0，或者有一个字节等待读取，则读取 1 个字节。"
"如果这个字节是 ``b\"\\x01\"`` 然后将剩余窗口大小增加步骤 5 中的窗口大小增量。"
"如果这个字节是 ``b\"\\x04\"`` 那么代表设备想要结束数据接收，"
"并且 ``b\"\\x04\"`` 应该写回设备并且之后不再发送代码。"
"（注意：如果有一个字节等待从设备读取，也不需要立即读取和操作，"
"只要当剩余窗口大小大于 0，设备就将继续消耗传入的字节。）"

#: ../../reference/repl.rst:257
msgid ""
"When all code has been written to the device, write ``b\"\\x04\"`` to "
"indicate end-of-data."
msgstr ""
"将所有代码写入设备后，写入 ``b\"\\x04\"`` 以标识数据结束。"

#: ../../reference/repl.rst:260
msgid ""
"Read from the device until ``b\"\\x04\"`` is received.  At this point the"
" device has received and compiled all of the code that was sent and is "
"executing it."
msgstr ""
"从设备读取数据直到收到 ``b\"\\x04\"``。此时，设备已经接收到并编译了所有发送的代码，并且开始执行。"

#: ../../reference/repl.rst:263
msgid ""
"The device outputs any characters produced by the executing code.  When "
"(if) the code finishes ``b\"\\x04\"`` will be output, followed by any "
"exception that was uncaught, followed again by ``b\"\\x04\"``.  It then "
"goes back to the standard raw REPL and outputs ``b\">\"``."
msgstr ""
"设备输出执行代码产生的任何字符。当代码结束（如果能）时， ``b\"\\x04\"`` 将被输出，"
"接着是未捕获的任何异常，再然后是 ``b\"\\x04\"``。"
"然后它返回到标准的 Raw REPL 并输出 `b\">\"`` 。"

#: ../../reference/repl.rst:268
msgid ""
"For example, starting at a new line at the normal (friendly) REPL, if you"
" write::"
msgstr ""
"例如，在正常（友好） REPL 的新一行中，如果你写："

#: ../../reference/repl.rst:272
msgid "Then the device will respond with something like::"
msgstr "然后设备将响应如下内容："

#: ../../reference/repl.rst:276
msgid "Broken down over time this looks like::"
msgstr "随着时间的推移，它看起来就会像这样："

#: ../../reference/repl.rst:293
msgid ""
"In this case the flow control window-size-increment is 128 and there are "
"two windows worth of data immediately available at the start, one from "
"the initial window-size-increment value and one from the explicit "
"``b\"\\x01\"`` value that is sent.  So this means up to 256 bytes can be "
"written to begin with before waiting or checking for more incoming flow-"
"control characters."
msgstr ""
"在这个案例下，流控制窗口增量大小为 128，"
"并且在开始时有两个窗口值的数据立即可用，一个来自初始窗口增量值，"
"另一个来自 ``b\"\\x01\"`` 发送的显式值。因此，这意味着在等待或检查更多传入流控制字符之前，"
"最多可以写入 256 个字节。"

#: ../../reference/repl.rst:299
msgid ""
"The ``tools/pyboard.py`` program uses the raw REPL, including raw-paste "
"mode, to execute Python code on a MicroPython-enabled board."
msgstr ""
"在 ``tools/pyboard.py`` 程序中，使用了 Raw REPL（包括 Raw 粘贴模式），"
"用以在支持 MicroPython 的开发板上执行 Python 代码。"

