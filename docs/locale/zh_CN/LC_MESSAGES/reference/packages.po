# SOME DESCRIPTIVE TITLE.
# Copyright (C) - The MicroPython Documentation is Copyright Â© 2014-2022,
# Damien P. George, Paul Sokolovsky, and contributors
# This file is distributed under the same license as the MicroPython
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: MicroPython 1.18\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-10 14:42+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../reference/packages.rst:4
msgid "Distribution packages, package management, and deploying applications"
msgstr ""

#: ../../reference/packages.rst:6
msgid ""
"Just as the \"big\" Python, MicroPython supports creation of \"third "
"party\" packages, distributing them, and easily installing them in each "
"user's environment. This chapter discusses how these actions are "
"achieved. Some familiarity with Python packaging is recommended."
msgstr ""

#: ../../reference/packages.rst:12
msgid "Overview"
msgstr ""

#: ../../reference/packages.rst:14
msgid ""
"Steps below represent a high-level workflow when creating and consuming "
"packages:"
msgstr ""

#: ../../reference/packages.rst:17
msgid ""
"Python modules and packages are turned into distribution package "
"archives, and published at the Python Package Index (PyPI)."
msgstr ""

#: ../../reference/packages.rst:19
msgid ""
":term:`upip` package manager can be used to install a distribution "
"package on a :term:`MicroPython port` with networking capabilities (for "
"example, on the Unix port)."
msgstr ""

#: ../../reference/packages.rst:22
msgid ""
"For ports without networking capabilities, an \"installation image\" can "
"be prepared on the Unix port, and transferred to a device by suitable "
"means."
msgstr ""

#: ../../reference/packages.rst:25
msgid ""
"For low-memory ports, the installation image can be frozen as the "
"bytecode into MicroPython executable, thus minimizing the memory storage "
"overheads."
msgstr ""

#: ../../reference/packages.rst:29
msgid "The sections below describe this process in details."
msgstr ""

#: ../../reference/packages.rst:32
msgid "Distribution packages"
msgstr ""

#: ../../reference/packages.rst:34
msgid ""
"Python modules and packages can be packaged into archives suitable for "
"transfer between systems, storing at the well-known location (PyPI), and "
"downloading on demand for deployment. These archives are known as "
"*distribution packages* (to differentiate them from Python packages "
"(means to organize Python source code))."
msgstr ""

#: ../../reference/packages.rst:40
msgid ""
"The MicroPython distribution package format is a well-known tar.gz "
"format, with some adaptations however. The Gzip compressor, used as an "
"external wrapper for TAR archives, by default uses 32KB dictionary size, "
"which means that to uncompress a compressed stream, 32KB of contiguous "
"memory needs to be allocated. This requirement may be not satisfiable on "
"low-memory devices, which may have total memory available less than that "
"amount, and even if not, a contiguous block like that may be hard to "
"allocate due to memory fragmentation. To accommodate these constraints, "
"MicroPython distribution packages use Gzip compression with the "
"dictionary size of 4K, which should be a suitable compromise with still "
"achieving some compression while being able to uncompressed even by the "
"smallest devices."
msgstr ""

#: ../../reference/packages.rst:53
msgid ""
"Besides the small compression dictionary size, MicroPython distribution "
"packages also have other optimizations, like removing any files from the "
"archive which aren't used by the installation process. In particular, "
":term:`upip` package manager doesn't execute ``setup.py`` during "
"installation (see below), and thus that file is not included in the "
"archive."
msgstr ""

#: ../../reference/packages.rst:59
msgid ""
"At the same time, these optimizations make MicroPython distribution "
"packages not compatible with :term:`CPython`'s package manager, ``pip``. "
"This isn't considered a big problem, because:"
msgstr ""

#: ../../reference/packages.rst:63
msgid ""
"Packages can be installed with :term:`upip`, and then can be used with "
"CPython (if they are compatible with it)."
msgstr ""

#: ../../reference/packages.rst:65
msgid ""
"In the other direction, majority of CPython packages would be "
"incompatible with MicroPython by various reasons, first of all, the "
"reliance on features not implemented by MicroPython."
msgstr ""

#: ../../reference/packages.rst:69
msgid ""
"Summing up, the MicroPython distribution package archives are highly "
"optimized for MicroPython's target environments, which are highly "
"resource constrained devices."
msgstr ""

#: ../../reference/packages.rst:75
msgid "``upip`` package manager"
msgstr ""

#: ../../reference/packages.rst:77
msgid ""
"MicroPython distribution packages are intended to be installed using the "
":term:`upip` package manager. :term:`upip` is a Python application which "
"is usually distributed (as frozen bytecode) with network-enabled "
":term:`MicroPython ports <MicroPython port>`. At the very least, "
":term:`upip` is available in the :term:`MicroPython Unix port`."
msgstr ""

#: ../../reference/packages.rst:83
msgid ""
"On any :term:`MicroPython port` providing :term:`upip`, it can be "
"accessed as following::"
msgstr ""

#: ../../reference/packages.rst:90
msgid ""
"Where *package_or_package_list* is the name of a distribution package to "
"install, or a list of such names to install multiple packages. Optional "
"*path* parameter specifies filesystem location to install under and "
"defaults to the standard library location (see below)."
msgstr ""

#: ../../reference/packages.rst:96
msgid "An example of installing a specific package and then using it::"
msgstr ""

#: ../../reference/packages.rst:104
msgid ""
"Note that the name of Python package and the name of distribution package"
" for it in general don't have to match, and oftentimes they don't. This "
"is because PyPI provides a central package repository for all different "
"Python implementations and versions, and thus distribution package names "
"may need to be namespaced for a particular implementation. For example, "
"all packages from `micropython-lib` follow this naming convention: for a "
"Python module or package named ``foo``, the distribution package name is "
"``micropython-foo``."
msgstr ""

#: ../../reference/packages.rst:113
msgid ""
"For the ports which run MicroPython executable from the OS command "
"prompts (like the Unix port), `upip` can be (and indeed, usually is) run "
"from the command line instead of MicroPython's own REPL. The commands "
"which corresponds to the example above are::"
msgstr ""

#: ../../reference/packages.rst:122
msgid "[TODO: Describe installation path.]"
msgstr ""

#: ../../reference/packages.rst:126
msgid "Cross-installing packages"
msgstr ""

#: ../../reference/packages.rst:128
msgid ""
"For :term:`MicroPython ports <MicroPython port>` without native "
"networking capabilities, the recommend process is \"cross-installing\" "
"them into a \"directory image\" using the :term:`MicroPython Unix port`, "
"and then transferring this image to a device by suitable means."
msgstr ""

#: ../../reference/packages.rst:133
msgid ""
"Installing to a directory image involves using ``-p`` switch to "
":term:`upip`::"
msgstr ""

#: ../../reference/packages.rst:137
msgid ""
"After this command, the package content (and contents of every dependency"
" packages) will be available in the ``install_dir/`` subdirectory. You "
"would need to transfer contents of this directory (without the "
"``install_dir/`` prefix) to the device, at the suitable location, where "
"it can be found by the Python ``import`` statement (see discussion of the"
" :term:`upip` installation path above)."
msgstr ""

#: ../../reference/packages.rst:146
msgid "Cross-installing packages with freezing"
msgstr ""

#: ../../reference/packages.rst:148
msgid ""
"For the low-memory :term:`MicroPython ports <MicroPython port>`, the "
"process described in the previous section does not provide the most "
"efficient resource usage,because the packages are installed in the source"
" form, so need to be compiled to the bytecome on each import. This "
"compilation requires RAM, and the resulting bytecode is also stored in "
"RAM, reducing its amount available for storing application data. "
"Moreover, the process above requires presence of the filesystem on a "
"device, and the most resource-constrained devices may not even have it."
msgstr ""

#: ../../reference/packages.rst:157
msgid ""
"The bytecode freezing is a process which resolves all the issues "
"mentioned above:"
msgstr ""

#: ../../reference/packages.rst:160
msgid "The source code is pre-compiled into bytecode and store as such."
msgstr ""

#: ../../reference/packages.rst:161
msgid "The bytecode is stored in ROM, not RAM."
msgstr ""

#: ../../reference/packages.rst:162
msgid "Filesystem is not required for frozen packages."
msgstr ""

#: ../../reference/packages.rst:164
msgid ""
"Using frozen bytecode requires building the executable (firmware) for a "
"given :term:`MicroPython port` from the C source code. Consequently, the "
"process is:"
msgstr ""

#: ../../reference/packages.rst:168
msgid ""
"Follow the instructions for a particular port on setting up a toolchain "
"and building the port. For example, for ESP8266 port, study instructions "
"in ``ports/esp8266/README.md`` and follow them. Make sure you can build "
"the port and deploy the resulting executable/firmware successfully before"
" proceeding to the next steps."
msgstr ""

#: ../../reference/packages.rst:173
msgid ""
"Build :term:`MicroPython Unix port` and make sure it is in your PATH and "
"you can execute ``micropython``."
msgstr ""

#: ../../reference/packages.rst:175
msgid "Change to port's directory (e.g. ``ports/esp8266/`` for ESP8266)."
msgstr ""

#: ../../reference/packages.rst:176
msgid ""
"Run ``make clean-frozen``. This step cleans up any previous modules which"
" were installed for freezing (consequently, you need to skip this step to"
" add additional modules, instead of starting from scratch)."
msgstr ""

#: ../../reference/packages.rst:180
msgid ""
"Run ``micropython -m upip install -p modules <packages>...`` to install "
"packages you want to freeze."
msgstr ""

#: ../../reference/packages.rst:182
msgid "Run ``make clean``."
msgstr ""

#: ../../reference/packages.rst:183
msgid "Run ``make``."
msgstr ""

#: ../../reference/packages.rst:185
msgid ""
"After this, you should have the executable/firmware with modules as the "
"bytecode inside, which you can deploy the usual way."
msgstr ""

#: ../../reference/packages.rst:188
msgid "Few notes:"
msgstr ""

#: ../../reference/packages.rst:190
msgid ""
"Step 5 in the sequence above assumes that the distribution package is "
"available from PyPI. If that is not the case, you would need to copy "
"Python source files manually to ``modules/`` subdirectory of the port "
"directory. (Note that upip does not support installing from e.g. version "
"control repositories)."
msgstr ""

#: ../../reference/packages.rst:195
msgid ""
"The firmware for baremetal devices usually has size restrictions, so "
"adding too many frozen modules may overflow it. Usually, you would get a "
"linking error if this happens. However, in some cases, an image may be "
"produced, which is not runnable on a device. Such cases are in general "
"bugs, and should be reported and further investigated. If you face such a"
" situation, as an initial step, you may want to decrease the amount of "
"frozen modules included."
msgstr ""

#: ../../reference/packages.rst:205
msgid "Creating distribution packages"
msgstr ""

#: ../../reference/packages.rst:207
msgid ""
"Distribution packages for MicroPython are created in the same manner as "
"for CPython or any other Python implementation, see references at the end"
" of chapter. Setuptools (instead of distutils) should be used, because "
"distutils do not support dependencies and other features. \"Source "
"distribution\" (``sdist``) format is used for packaging. The post-"
"processing discussed above, (and pre-processing discussed in the "
"following section) is achieved by using custom ``sdist`` command for "
"setuptools. Thus, packaging steps remain the same as for the standard "
"setuptools, the user just needs to override ``sdist`` command "
"implementation by passing the appropriate argument to ``setup()`` call::"
msgstr ""

#: ../../reference/packages.rst:226
msgid ""
"The sdist_upip.py module as referenced above can be found in "
"`micropython-lib`: https://github.com/micropython/micropython-"
"lib/blob/master/sdist_upip.py"
msgstr ""

#: ../../reference/packages.rst:232
msgid "Application resources"
msgstr ""

#: ../../reference/packages.rst:234
msgid ""
"A complete application, besides the source code, oftentimes also consists"
" of data files, e.g. web page templates, game images, etc. It's clear how"
" to deal with those when application is installed manually - you just put"
" those data files in the filesystem at some location and use the normal "
"file access functions."
msgstr ""

#: ../../reference/packages.rst:240
msgid ""
"The situation is different when deploying applications from packages - "
"this is more advanced, streamlined and flexible way, but also requires "
"more advanced approach to accessing data files. This approach is treating"
" the data files as \"resources\", and abstracting away access to them."
msgstr ""

#: ../../reference/packages.rst:245
msgid ""
"Python supports resource access using its \"setuptools\" library, using "
"``pkg_resources`` module. MicroPython, following its usual approach, "
"implements subset of the functionality of that module, specifically "
"``pkg_resources.resource_stream(package, resource)`` function. The idea "
"is that an application calls this function, passing a resource "
"identifier, which is a relative path to data file within the specified "
"package (usually top-level application package). It returns a stream "
"object which can be used to access resource contents. Thus, the "
"``resource_stream()`` emulates interface of the standard `open()` "
"function."
msgstr ""

#: ../../reference/packages.rst:256
msgid ""
"Implementation-wise, ``resource_stream()`` uses file operations "
"underlyingly, if distribution package is install in the filesystem. "
"However, it also supports functioning without the underlying filesystem, "
"e.g. if the package is frozen as the bytecode. This however requires an "
"extra intermediate step when packaging application - creation of \"Python"
" resource module\"."
msgstr ""

#: ../../reference/packages.rst:263
msgid ""
"The idea of this module is to convert binary data to a Python bytes "
"object, and put it into the dictionary, indexed by the resource name. "
"This conversion is done automatically using overridden ``sdist`` command "
"described in the previous section."
msgstr ""

#: ../../reference/packages.rst:268
msgid ""
"Let's trace the complete process using the following example. Suppose "
"your application has the following structure::"
msgstr ""

#: ../../reference/packages.rst:278
msgid ""
"``__main__.py`` and ``utils.py`` should access resources using the "
"following calls::"
msgstr ""

#: ../../reference/packages.rst:286
msgid ""
"You can develop and debug using the :term:`MicroPython Unix port` as "
"usual. When time comes to make a distribution package out of it, just use"
" overridden \"sdist\" command from sdist_upip.py module as described in "
"the previous section."
msgstr ""

#: ../../reference/packages.rst:291
msgid ""
"This will create a Python resource module named ``R.py``, based on the "
"files declared in ``MANIFEST`` or ``MANIFEST.in`` files (any non-``.py`` "
"file will be considered a resource and added to ``R.py``) - before "
"proceeding with the normal packaging steps."
msgstr ""

#: ../../reference/packages.rst:296
msgid ""
"Prepared like this, your application will work both when deployed to "
"filesystem and as frozen bytecode."
msgstr ""

#: ../../reference/packages.rst:299
msgid "If you would like to debug ``R.py`` creation, you can run::"
msgstr ""

#: ../../reference/packages.rst:303
msgid ""
"Alternatively, you can use tools/mpy_bin2res.py script from the "
"MicroPython distribution, in which can you will need to pass paths to all"
" resource files::"
msgstr ""

#: ../../reference/packages.rst:310
msgid "References"
msgstr ""

#: ../../reference/packages.rst:312
msgid "Python Packaging User Guide: https://packaging.python.org/"
msgstr ""

#: ../../reference/packages.rst:313
msgid "Setuptools documentation: https://setuptools.readthedocs.io/"
msgstr ""

#: ../../reference/packages.rst:314
msgid "Distutils documentation: https://docs.python.org/3/library/distutils.html"
msgstr ""

