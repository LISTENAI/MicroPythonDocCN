# SOME DESCRIPTIVE TITLE.
# Copyright (C) - The MicroPython Documentation is Copyright Â© 2014-2022,
# Damien P. George, Paul Sokolovsky, and contributors
# This file is distributed under the same license as the MicroPython
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: MicroPython 1.18\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-10 14:42+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../reference/asm_thumb2_logical_bit.rst:2
msgid "Logical & bitwise instructions"
msgstr ""

#: ../../reference/asm_thumb2_logical_bit.rst:5
msgid "Document conventions"
msgstr ""

#: ../../reference/asm_thumb2_logical_bit.rst:7
msgid ""
"Notation: ``Rd, Rn`` denote ARM registers R0-R7 except in the case of the"
" special instructions where R0-R15 may be used. ``Rn<a-b>`` denotes an "
"ARM register whose contents must lie in range ``a <= contents <= b``. In "
"the case of instructions with two register arguments, it is permissible "
"for them to be identical. For example the following will zero R0 (Python "
"``R0 ^= R0``) regardless of its initial contents."
msgstr ""

#: ../../reference/asm_thumb2_logical_bit.rst:13
msgid "eor(r0, r0)"
msgstr ""

#: ../../reference/asm_thumb2_logical_bit.rst:15
msgid "These instructions affect the condition flags except where stated."
msgstr ""

#: ../../reference/asm_thumb2_logical_bit.rst:18
msgid "Logical instructions"
msgstr ""

#: ../../reference/asm_thumb2_logical_bit.rst:20
msgid "and\\_(Rd, Rn) ``Rd &= Rn``"
msgstr ""

#: ../../reference/asm_thumb2_logical_bit.rst:21
msgid "orr(Rd, Rn) ``Rd |= Rn``"
msgstr ""

#: ../../reference/asm_thumb2_logical_bit.rst:22
msgid "eor(Rd, Rn) ``Rd ^= Rn``"
msgstr ""

#: ../../reference/asm_thumb2_logical_bit.rst:23
msgid "mvn(Rd, Rn) ``Rd = Rn ^ 0xffffffff`` i.e. Rd = 1's complement of Rn"
msgstr ""

#: ../../reference/asm_thumb2_logical_bit.rst:24
msgid "bic(Rd, Rn) ``Rd &= ~Rn`` bit clear Rd using mask in Rn"
msgstr ""

#: ../../reference/asm_thumb2_logical_bit.rst:26
msgid ""
"Note the use of \"and\\_\" instead of \"and\", because \"and\" is a "
"reserved keyword in Python."
msgstr ""

#: ../../reference/asm_thumb2_logical_bit.rst:29
msgid "Shift and rotation instructions"
msgstr ""

#: ../../reference/asm_thumb2_logical_bit.rst:31
msgid "lsl(Rd, Rn<0-31>) ``Rd <<= Rn``"
msgstr ""

#: ../../reference/asm_thumb2_logical_bit.rst:32
msgid "lsr(Rd, Rn<1-32>) ``Rd = (Rd & 0xffffffff) >> Rn`` Logical shift right"
msgstr ""

#: ../../reference/asm_thumb2_logical_bit.rst:33
msgid "asr(Rd, Rn<1-32>) ``Rd >>= Rn`` arithmetic shift right"
msgstr ""

#: ../../reference/asm_thumb2_logical_bit.rst:34
msgid ""
"ror(Rd, Rn<1-31>) ``Rd = rotate_right(Rd, Rn)`` Rd is rotated right Rn "
"bits."
msgstr ""

#: ../../reference/asm_thumb2_logical_bit.rst:36
msgid ""
"A rotation by (for example) three bits works as follows. If Rd initially "
"contains bits ``b31 b30..b0`` after rotation it will contain ``b2 b1 b0 "
"b31 b30..b3``"
msgstr ""

#: ../../reference/asm_thumb2_logical_bit.rst:40
msgid "Special instructions"
msgstr ""

#: ../../reference/asm_thumb2_logical_bit.rst:42
msgid "Condition codes are unaffected by these instructions."
msgstr ""

#: ../../reference/asm_thumb2_logical_bit.rst:44
msgid "clz(Rd, Rn) ``Rd = count_leading_zeros(Rn)``"
msgstr ""

#: ../../reference/asm_thumb2_logical_bit.rst:46
msgid ""
"count_leading_zeros(Rn) returns the number of binary zero bits before the"
" first binary one bit in Rn."
msgstr ""

#: ../../reference/asm_thumb2_logical_bit.rst:48
msgid "rbit(Rd, Rn) ``Rd = bit_reverse(Rn)``"
msgstr ""

#: ../../reference/asm_thumb2_logical_bit.rst:50
msgid ""
"bit_reverse(Rn) returns the bit-reversed contents of Rn. If Rn contains "
"bits ``b31 b30..b0`` Rd will be set to ``b0 b1 b2..b31``"
msgstr ""

#: ../../reference/asm_thumb2_logical_bit.rst:53
msgid ""
"Trailing zeros may be counted by performing a bit reverse prior to "
"executing clz."
msgstr ""

