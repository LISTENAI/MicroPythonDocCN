# SOME DESCRIPTIVE TITLE.
# Copyright (C) - The MicroPython Documentation is Copyright Â© 2014-2022,
# Damien P. George, Paul Sokolovsky, and contributors
# This file is distributed under the same license as the MicroPython
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: MicroPython 1.18\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-10 14:42+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../library/uctypes.rst:2
msgid ":mod:`uctypes` -- access binary data in a structured way"
msgstr ""

#: ../../library/uctypes.rst:7
msgid ""
"This module implements \"foreign data interface\" for MicroPython. The "
"idea behind it is similar to CPython's ``ctypes`` modules, but the actual"
" API is different, streamlined and optimized for small size. The basic "
"idea of the module is to define data structure layout with about the same"
" power as the C language allows, and then access it using familiar dot-"
"syntax to reference sub-fields."
msgstr ""

#: ../../library/uctypes.rst:16
msgid ""
"``uctypes`` module allows access to arbitrary memory addresses of the "
"machine (including I/O and control registers). Uncareful usage of it may "
"lead to crashes, data loss, and even hardware malfunction."
msgstr ""

#: ../../library/uctypes.rst:23
msgid "Module :mod:`struct`"
msgstr ""

#: ../../library/uctypes.rst:23
msgid ""
"Standard Python way to access binary data structures (doesn't scale well "
"to large and complex structures)."
msgstr ""

#: ../../library/uctypes.rst:26
msgid "Usage examples::"
msgstr ""

#: ../../library/uctypes.rst:85
msgid "Defining structure layout"
msgstr ""

#: ../../library/uctypes.rst:87
msgid ""
"Structure layout is defined by a \"descriptor\" - a Python dictionary "
"which encodes field names as keys and other properties required to access"
" them as associated values::"
msgstr ""

#: ../../library/uctypes.rst:97
msgid ""
"Currently, ``uctypes`` requires explicit specification of offsets for "
"each field. Offset are given in bytes from the structure start."
msgstr ""

#: ../../library/uctypes.rst:100
msgid "Following are encoding examples for various field types:"
msgstr ""

#: ../../library/uctypes.rst:102
msgid "Scalar types::"
msgstr ""

#: ../../library/uctypes.rst:106
msgid ""
"in other words, the value is a scalar type identifier ORed with a field "
"offset (in bytes) from the start of the structure."
msgstr ""

#: ../../library/uctypes.rst:109
msgid "Recursive structures::"
msgstr ""

#: ../../library/uctypes.rst:116
msgid ""
"i.e. value is a 2-tuple, first element of which is an offset, and second "
"is a structure descriptor dictionary (note: offsets in recursive "
"descriptors are relative to the structure it defines). Of course, "
"recursive structures can be specified not just by a literal dictionary, "
"but by referring to a structure descriptor dictionary (defined earlier) "
"by name."
msgstr ""

#: ../../library/uctypes.rst:122
msgid "Arrays of primitive types::"
msgstr ""

#: ../../library/uctypes.rst:126
msgid ""
"i.e. value is a 2-tuple, first element of which is ARRAY flag ORed with "
"offset, and second is scalar element type ORed number of elements in the "
"array."
msgstr ""

#: ../../library/uctypes.rst:130
msgid "Arrays of aggregate types::"
msgstr ""

#: ../../library/uctypes.rst:134
msgid ""
"i.e. value is a 3-tuple, first element of which is ARRAY flag ORed with "
"offset, second is a number of elements in the array, and third is a "
"descriptor of element type."
msgstr ""

#: ../../library/uctypes.rst:138
msgid "Pointer to a primitive type::"
msgstr ""

#: ../../library/uctypes.rst:142
msgid ""
"i.e. value is a 2-tuple, first element of which is PTR flag ORed with "
"offset, and second is a scalar element type."
msgstr ""

#: ../../library/uctypes.rst:145
msgid "Pointer to an aggregate type::"
msgstr ""

#: ../../library/uctypes.rst:149
msgid ""
"i.e. value is a 2-tuple, first element of which is PTR flag ORed with "
"offset, second is a descriptor of type pointed to."
msgstr ""

#: ../../library/uctypes.rst:152
msgid "Bitfields::"
msgstr ""

#: ../../library/uctypes.rst:156
msgid ""
"i.e. value is a type of scalar value containing given bitfield (typenames"
" are similar to scalar types, but prefixes with ``BF``), ORed with offset"
" for scalar value containing the bitfield, and further ORed with values "
"for bit position and bit length of the bitfield within the scalar value, "
"shifted by BF_POS and BF_LEN bits, respectively. A bitfield position is "
"counted from the least significant bit of the scalar (having position of "
"0), and is the number of right-most bit of a field (in other words, it's "
"a number of bits a scalar needs to be shifted right to extract the "
"bitfield)."
msgstr ""

#: ../../library/uctypes.rst:165
msgid ""
"In the example above, first a UINT16 value will be extracted at offset 0 "
"(this detail may be important when accessing hardware registers, where "
"particular access size and alignment are required), and then bitfield "
"whose rightmost bit is *lsbit* bit of this UINT16, and length is "
"*bitsize* bits, will be extracted. For example, if *lsbit* is 0 and "
"*bitsize* is 8, then effectively it will access least-significant byte of"
" UINT16."
msgstr ""

#: ../../library/uctypes.rst:173
msgid ""
"Note that bitfield operations are independent of target byte endianness, "
"in particular, example above will access least-significant byte of UINT16"
" in both little- and big-endian structures. But it depends on the least "
"significant bit being numbered 0. Some targets may use different "
"numbering in their native ABI, but ``uctypes`` always uses the normalized"
" numbering described above."
msgstr ""

#: ../../library/uctypes.rst:181
msgid "Module contents"
msgstr ""

#: ../../library/uctypes.rst:185
msgid ""
"Instantiate a \"foreign data structure\" object based on structure "
"address in memory, descriptor (encoded as a dictionary), and layout type "
"(see below)."
msgstr ""

#: ../../library/uctypes.rst:190
msgid ""
"Layout type for a little-endian packed structure. (Packed means that "
"every field occupies exactly as many bytes as defined in the descriptor, "
"i.e. the alignment is 1)."
msgstr ""

#: ../../library/uctypes.rst:196
msgid "Layout type for a big-endian packed structure."
msgstr ""

#: ../../library/uctypes.rst:200
msgid ""
"Layout type for a native structure - with data endianness and alignment "
"conforming to the ABI of the system on which MicroPython runs."
msgstr ""

#: ../../library/uctypes.rst:205
msgid ""
"Return size of data structure in bytes. The *struct* argument can be "
"either a structure class or a specific instantiated structure object (or "
"its aggregate field)."
msgstr ""

#: ../../library/uctypes.rst:211
msgid ""
"Return address of an object. Argument should be bytes, bytearray or other"
" object supporting buffer protocol (and address of this buffer is what "
"actually returned)."
msgstr ""

#: ../../library/uctypes.rst:217
msgid ""
"Capture memory at the given address and size as bytes object. As bytes "
"object is immutable, memory is actually duplicated and copied into bytes "
"object, so if memory contents change later, created object retains "
"original value."
msgstr ""

#: ../../library/uctypes.rst:224
msgid ""
"Capture memory at the given address and size as bytearray object. Unlike "
"bytes_at() function above, memory is captured by reference, so it can be "
"both written too, and you will access current value at the given memory "
"address."
msgstr ""

#: ../../library/uctypes.rst:238
msgid ""
"Integer types for structure descriptors. Constants for 8, 16, 32, and 64 "
"bit types are provided, both signed and unsigned."
msgstr ""

#: ../../library/uctypes.rst:244
msgid "Floating-point types for structure descriptors."
msgstr ""

#: ../../library/uctypes.rst:248
msgid ""
"``VOID`` is an alias for ``UINT8``, and is provided to conveniently "
"define C's void pointers: ``(uctypes.PTR, uctypes.VOID)``."
msgstr ""

#: ../../library/uctypes.rst:254
msgid ""
"Type constants for pointers and arrays. Note that there is no explicit "
"constant for structures, it's implicit: an aggregate type without ``PTR``"
" or ``ARRAY`` flags is a structure."
msgstr ""

#: ../../library/uctypes.rst:259
msgid "Structure descriptors and instantiating structure objects"
msgstr ""

#: ../../library/uctypes.rst:261
msgid ""
"Given a structure descriptor dictionary and its layout type, you can "
"instantiate a specific structure instance at a given memory address using"
" :class:`uctypes.struct()` constructor. Memory address usually comes from"
" following sources:"
msgstr ""

#: ../../library/uctypes.rst:266
msgid ""
"Predefined address, when accessing hardware registers on a baremetal "
"system. Lookup these addresses in datasheet for a particular MCU/SoC."
msgstr ""

#: ../../library/uctypes.rst:268
msgid ""
"As a return value from a call to some FFI (Foreign Function Interface) "
"function."
msgstr ""

#: ../../library/uctypes.rst:270
msgid ""
"From `uctypes.addressof()`, when you want to pass arguments to an FFI "
"function, or alternatively, to access some data for I/O (for example, "
"data read from a file or network socket)."
msgstr ""

#: ../../library/uctypes.rst:275
msgid "Structure objects"
msgstr ""

#: ../../library/uctypes.rst:277
msgid ""
"Structure objects allow accessing individual fields using standard dot "
"notation: ``my_struct.substruct1.field1``. If a field is of scalar type, "
"getting it will produce a primitive value (Python integer or float) "
"corresponding to the value contained in a field. A scalar field can also "
"be assigned to."
msgstr ""

#: ../../library/uctypes.rst:283
msgid ""
"If a field is an array, its individual elements can be accessed with the "
"standard subscript operator ``[]`` - both read and assigned to."
msgstr ""

#: ../../library/uctypes.rst:286
msgid ""
"If a field is a pointer, it can be dereferenced using ``[0]`` syntax "
"(corresponding to C ``*`` operator, though ``[0]`` works in C too). "
"Subscripting a pointer with other integer values but 0 are also "
"supported, with the same semantics as in C."
msgstr ""

#: ../../library/uctypes.rst:291
msgid ""
"Summing up, accessing structure fields generally follows the C syntax, "
"except for pointer dereference, when you need to use ``[0]`` operator "
"instead of ``*``."
msgstr ""

#: ../../library/uctypes.rst:296
msgid "Limitations"
msgstr ""

#: ../../library/uctypes.rst:298
msgid ""
"1. Accessing non-scalar fields leads to allocation of intermediate "
"objects to represent them. This means that special care should be taken "
"to layout a structure which needs to be accessed when memory allocation "
"is disabled (e.g. from an interrupt). The recommendations are:"
msgstr ""

#: ../../library/uctypes.rst:303
msgid ""
"Avoid accessing nested structures. For example, instead of "
"``mcu_registers.peripheral_a.register1``, define separate layout "
"descriptors for each peripheral, to be accessed as "
"``peripheral_a.register1``. Or just cache a particular peripheral: "
"``peripheral_a = mcu_registers.peripheral_a``. If a register consists of "
"multiple bitfields, you would need to cache references to a particular "
"register: ``reg_a = mcu_registers.peripheral_a.reg_a``."
msgstr ""

#: ../../library/uctypes.rst:310
msgid ""
"Avoid other non-scalar data, like arrays. For example, instead of "
"``peripheral_a.register[0]`` use ``peripheral_a.register0``. Again, an "
"alternative is to cache intermediate values, e.g. ``register0 = "
"peripheral_a.register[0]``."
msgstr ""

#: ../../library/uctypes.rst:315
msgid ""
"2. Range of offsets supported by the ``uctypes`` module is limited. The "
"exact range supported is considered an implementation detail, and the "
"general suggestion is to split structure definitions to cover from a few "
"kilobytes to a few dozen of kilobytes maximum. In most cases, this is a "
"natural situation anyway, e.g. it doesn't make sense to define all "
"registers of an MCU (spread over 32-bit address space) in one structure, "
"but rather a peripheral block by peripheral block. In some extreme cases,"
" you may need to split a structure in several parts artificially (e.g. if"
" accessing native data structure with multi-megabyte array in the middle,"
" though that would be a very synthetic case)."
msgstr ""

