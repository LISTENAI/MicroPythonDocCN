# SOME DESCRIPTIVE TITLE.
# Copyright (C) - The MicroPython Documentation is Copyright Â© 2014-2022,
# Damien P. George, Paul Sokolovsky, and contributors
# This file is distributed under the same license as the MicroPython
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: MicroPython 1.18\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-10 14:42+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../library/os.rst:2
msgid ":mod:`os` -- basic \"operating system\" services"
msgstr ""

#: ../../library/os.rst:7
msgid "|see_cpython_module| :mod:`python:os`."
msgstr ""

#: ../../library/os.rst:9
msgid ""
"The ``os`` module contains functions for filesystem access and mounting, "
"terminal redirection and duplication, and the ``uname`` and ``urandom`` "
"functions."
msgstr ""

#: ../../library/os.rst:14
msgid "General functions"
msgstr ""

#: ../../library/os.rst:18
msgid ""
"Return a tuple (possibly a named tuple) containing information about the "
"underlying machine and/or its operating system.  The tuple has five "
"fields in the following order, each of them being a string:"
msgstr ""

#: ../../library/os.rst:22
msgid "``sysname`` -- the name of the underlying system"
msgstr ""

#: ../../library/os.rst:23
msgid "``nodename`` -- the network name (can be the same as ``sysname``)"
msgstr ""

#: ../../library/os.rst:24
msgid "``release`` -- the version of the underlying system"
msgstr ""

#: ../../library/os.rst:25
msgid "``version`` -- the MicroPython version and build date"
msgstr ""

#: ../../library/os.rst:26
msgid "``machine`` -- an identifier for the underlying hardware (eg board, CPU)"
msgstr ""

#: ../../library/os.rst:30
msgid ""
"Return a bytes object with *n* random bytes. Whenever possible, it is "
"generated by the hardware random number generator."
msgstr ""

#: ../../library/os.rst:34
msgid "Filesystem access"
msgstr ""

#: ../../library/os.rst:38
msgid "Change current directory."
msgstr ""

#: ../../library/os.rst:42
msgid "Get the current directory."
msgstr ""

#: ../../library/os.rst:46
msgid ""
"This function returns an iterator which then yields tuples corresponding "
"to the entries in the directory that it is listing.  With no argument it "
"lists the current directory, otherwise it lists the directory given by "
"*dir*."
msgstr ""

#: ../../library/os.rst:50
msgid "The tuples have the form *(name, type, inode[, size])*:"
msgstr ""

#: ../../library/os.rst:52
msgid ""
"*name* is a string (or bytes if *dir* is a bytes object) and is the name "
"of the entry;"
msgstr ""

#: ../../library/os.rst:54
msgid ""
"*type* is an integer that specifies the type of the entry, with 0x4000 "
"for directories and 0x8000 for regular files;"
msgstr ""

#: ../../library/os.rst:56
msgid ""
"*inode* is an integer corresponding to the inode of the file, and may be "
"0 for filesystems that don't have such a notion."
msgstr ""

#: ../../library/os.rst:58
msgid ""
"Some platforms may return a 4-tuple that includes the entry's *size*.  "
"For file entries, *size* is an integer representing the size of the file "
"or -1 if unknown.  Its meaning is currently undefined for directory "
"entries."
msgstr ""

#: ../../library/os.rst:65
msgid ""
"With no argument, list the current directory.  Otherwise list the given "
"directory."
msgstr ""

#: ../../library/os.rst:69
msgid "Create a new directory."
msgstr ""

#: ../../library/os.rst:73
msgid "Remove a file."
msgstr ""

#: ../../library/os.rst:77
msgid "Remove a directory."
msgstr ""

#: ../../library/os.rst:81
msgid "Rename a file."
msgstr ""

#: ../../library/os.rst:85
msgid "Get the status of a file or directory."
msgstr ""

#: ../../library/os.rst:89
msgid "Get the status of a fileystem."
msgstr ""

#: ../../library/os.rst:91
msgid "Returns a tuple with the filesystem information in the following order:"
msgstr ""

#: ../../library/os.rst:93
msgid "``f_bsize`` -- file system block size"
msgstr ""

#: ../../library/os.rst:94
msgid "``f_frsize`` -- fragment size"
msgstr ""

#: ../../library/os.rst:95
msgid "``f_blocks`` -- size of fs in f_frsize units"
msgstr ""

#: ../../library/os.rst:96
msgid "``f_bfree`` -- number of free blocks"
msgstr ""

#: ../../library/os.rst:97
msgid "``f_bavail`` -- number of free blocks for unprivileged users"
msgstr ""

#: ../../library/os.rst:98
msgid "``f_files`` -- number of inodes"
msgstr ""

#: ../../library/os.rst:99
msgid "``f_ffree`` -- number of free inodes"
msgstr ""

#: ../../library/os.rst:100
msgid "``f_favail`` -- number of free inodes for unprivileged users"
msgstr ""

#: ../../library/os.rst:101
msgid "``f_flag`` -- mount flags"
msgstr ""

#: ../../library/os.rst:102
msgid "``f_namemax`` -- maximum filename length"
msgstr ""

#: ../../library/os.rst:104
msgid ""
"Parameters related to inodes: ``f_files``, ``f_ffree``, ``f_avail`` and "
"the ``f_flags`` parameter may return ``0`` as they can be unavailable in "
"a port-specific implementation."
msgstr ""

#: ../../library/os.rst:110
msgid "Sync all filesystems."
msgstr ""

#: ../../library/os.rst:113
msgid "Terminal redirection and duplication"
msgstr ""

#: ../../library/os.rst:117
msgid ""
"Duplicate or switch the MicroPython terminal (the REPL) on the given "
"`stream`-like object. The *stream_object* argument must be a native "
"stream object, or derive from ``io.IOBase`` and implement the "
"``readinto()`` and ``write()`` methods.  The stream should be in non-"
"blocking mode and ``readinto()`` should return ``None`` if there is no "
"data available for reading."
msgstr ""

#: ../../library/os.rst:123
msgid ""
"After calling this function all terminal output is repeated on this "
"stream, and any input that is available on the stream is passed on to the"
" terminal input."
msgstr ""

#: ../../library/os.rst:126
msgid ""
"The *index* parameter should be a non-negative integer and specifies "
"which duplication slot is set.  A given port may implement more than one "
"slot (slot 0 will always be available) and in that case terminal input "
"and output is duplicated on all the slots that are set."
msgstr ""

#: ../../library/os.rst:131
msgid ""
"If ``None`` is passed as the *stream_object* then duplication is "
"cancelled on the slot given by *index*."
msgstr ""

#: ../../library/os.rst:134
msgid "The function returns the previous stream-like object in the given slot."
msgstr ""

#: ../../library/os.rst:137
msgid "Filesystem mounting"
msgstr ""

#: ../../library/os.rst:139
msgid ""
"Some ports provide a Virtual Filesystem (VFS) and the ability to mount "
"multiple \"real\" filesystems within this VFS.  Filesystem objects can be"
" mounted at either the root of the VFS, or at a subdirectory that lives "
"in the root.  This allows dynamic and flexible configuration of the "
"filesystem that is seen by Python programs.  Ports that have this "
"functionality provide the :func:`mount` and :func:`umount` functions, and"
" possibly various filesystem implementations represented by VFS classes."
msgstr ""

#: ../../library/os.rst:149
msgid ""
"Mount the filesystem object *fsobj* at the location in the VFS given by "
"the *mount_point* string.  *fsobj* can be a a VFS object that has a "
"``mount()`` method, or a block device.  If it's a block device then the "
"filesystem type is automatically detected (an exception is raised if no "
"filesystem was recognised).  *mount_point* may be ``'/'`` to mount "
"*fsobj* at the root, or ``'/<name>'`` to mount it at a subdirectory under"
" the root."
msgstr ""

#: ../../library/os.rst:156
msgid "If *readonly* is ``True`` then the filesystem is mounted read-only."
msgstr ""

#: ../../library/os.rst:158
msgid ""
"During the mount process the method ``mount()`` is called on the "
"filesystem object."
msgstr ""

#: ../../library/os.rst:161
msgid "Will raise ``OSError(EPERM)`` if *mount_point* is already mounted."
msgstr ""

#: ../../library/os.rst:165
msgid ""
"Unmount a filesystem. *mount_point* can be a string naming the mount "
"location, or a previously-mounted filesystem object.  During the unmount "
"process the method ``umount()`` is called on the filesystem object."
msgstr ""

#: ../../library/os.rst:169
msgid "Will raise ``OSError(EINVAL)`` if *mount_point* is not found."
msgstr ""

#: ../../library/os.rst:173
msgid ""
"Create a filesystem object that uses the FAT filesystem format.  Storage "
"of the FAT filesystem is provided by *block_dev*. Objects created by this"
" constructor can be mounted using :func:`mount`."
msgstr ""

#: ../../library/os.rst:179
msgid "Build a FAT filesystem on *block_dev*."
msgstr ""

#: ../../library/os.rst:183
msgid ""
"Create a filesystem object that uses the `littlefs v1 filesystem "
"format`_. Storage of the littlefs filesystem is provided by *block_dev*, "
"which must support the :ref:`extended interface <block-device-"
"interface>`. Objects created by this constructor can be mounted using "
":func:`mount`."
msgstr ""

#: ../../library/os.rst:188 ../../library/os.rst:212
msgid "See :ref:`filesystem` for more information."
msgstr ""

#: ../../library/os.rst:192
msgid "Build a Lfs1 filesystem on *block_dev*."
msgstr ""

#: ../../library/os.rst:194
msgid ""
"There are reports of littlefs v1 failing in certain situations, for "
"details see `littlefs issue 347`_."
msgstr ""

#: ../../library/os.rst:199
msgid ""
"Create a filesystem object that uses the `littlefs v2 filesystem "
"format`_. Storage of the littlefs filesystem is provided by *block_dev*, "
"which must support the :ref:`extended interface <block-device-"
"interface>`. Objects created by this constructor can be mounted using "
":func:`mount`."
msgstr ""

#: ../../library/os.rst:204
msgid ""
"The *mtime* argument enables modification timestamps for files, stored "
"using littlefs attributes.  This option can be disabled or enabled "
"differently each mount time and timestamps will only be added or updated "
"if *mtime* is enabled, otherwise the timestamps will remain untouched.  "
"Littlefs v2 filesystems without timestamps will work without reformatting"
" and timestamps will be added transparently to existing files once they "
"are opened for writing.  When *mtime* is enabled `os.stat` on files "
"without timestamps will return 0 for the timestamp."
msgstr ""

#: ../../library/os.rst:216
msgid "Build a Lfs2 filesystem on *block_dev*."
msgstr ""

#: ../../library/os.rst:218
msgid ""
"There are reports of littlefs v2 failing in certain situations, for "
"details see `littlefs issue 295`_."
msgstr ""

#: ../../library/os.rst:227
msgid "Block devices"
msgstr ""

#: ../../library/os.rst:229
msgid ""
"A block device is an object which implements the block protocol. This "
"enables a device to support MicroPython filesystems. The physical "
"hardware is represented by a user defined class. The "
":class:`AbstractBlockDev` class is a template for the design of such a "
"class: MicroPython does not actually provide that class, but an actual "
"block device class must implement the methods described below."
msgstr ""

#: ../../library/os.rst:235
msgid ""
"A concrete implementation of this class will usually allow access to the "
"memory-like functionality of a piece of hardware (like flash memory). A "
"block device can be formatted to any supported filesystem and mounted "
"using ``os`` methods."
msgstr ""

#: ../../library/os.rst:240
msgid ""
"See :ref:`filesystem` for example implementations of block devices using "
"the two variants of the block protocol described below."
msgstr ""

#: ../../library/os.rst:246
msgid "Simple and extended interface"
msgstr ""

#: ../../library/os.rst:248
msgid ""
"There are two compatible signatures for the ``readblocks`` and "
"``writeblocks`` methods (see below), in order to support a variety of use"
" cases.  A given block device may implement one form or the other, or "
"both at the same time. The second form (with the offset parameter) is "
"referred to as the \"extended interface\"."
msgstr ""

#: ../../library/os.rst:253
msgid ""
"Some filesystems (such as littlefs) that require more control over write "
"operations, for example writing to sub-block regions without erasing, may"
" require that the block device supports the extended interface."
msgstr ""

#: ../../library/os.rst:259
msgid ""
"Construct a block device object.  The parameters to the constructor are "
"dependent on the specific block device."
msgstr ""

#: ../../library/os.rst:265
msgid ""
"The first form reads aligned, multiples of blocks. Starting at the block "
"given by the index *block_num*, read blocks from the device into *buf* "
"(an array of bytes). The number of blocks to read is given by the length "
"of *buf*, which will be a multiple of the block size."
msgstr ""

#: ../../library/os.rst:271
msgid ""
"The second form allows reading at arbitrary locations within a block, and"
" arbitrary lengths. Starting at block index *block_num*, and byte offset "
"within that block of *offset*, read bytes from the device into *buf* (an "
"array of bytes). The number of bytes to read is given by the length of "
"*buf*."
msgstr ""

#: ../../library/os.rst:280
msgid ""
"The first form writes aligned, multiples of blocks, and requires that the"
" blocks that are written to be first erased (if necessary) by this "
"method. Starting at the block given by the index *block_num*, write "
"blocks from *buf* (an array of bytes) to the device. The number of blocks"
" to write is given by the length of *buf*, which will be a multiple of "
"the block size."
msgstr ""

#: ../../library/os.rst:287
msgid ""
"The second form allows writing at arbitrary locations within a block, and"
" arbitrary lengths.  Only the bytes being written should be changed, and "
"the caller of this method must ensure that the relevant blocks are erased"
" via a prior ``ioctl`` call. Starting at block index *block_num*, and "
"byte offset within that block of *offset*, write bytes from *buf* (an "
"array of bytes) to the device. The number of bytes to write is given by "
"the length of *buf*."
msgstr ""

#: ../../library/os.rst:295
msgid ""
"Note that implementations must never implicitly erase blocks if the "
"offset argument is specified, even if it is zero."
msgstr ""

#: ../../library/os.rst:300
msgid ""
"Control the block device and query its parameters.  The operation to "
"perform is given by *op* which is one of the following integers:"
msgstr ""

#: ../../library/os.rst:303
msgid "1 -- initialise the device (*arg* is unused)"
msgstr ""

#: ../../library/os.rst:304
msgid "2 -- shutdown the device (*arg* is unused)"
msgstr ""

#: ../../library/os.rst:305
msgid "3 -- sync the device (*arg* is unused)"
msgstr ""

#: ../../library/os.rst:306
msgid ""
"4 -- get a count of the number of blocks, should return an integer (*arg*"
" is unused)"
msgstr ""

#: ../../library/os.rst:308
msgid ""
"5 -- get the number of bytes in a block, should return an integer, or "
"``None`` in which case the default value of 512 is used (*arg* is unused)"
msgstr ""

#: ../../library/os.rst:311
msgid "6 -- erase a block, *arg* is the block number to erase"
msgstr ""

#: ../../library/os.rst:313
msgid ""
"As a minimum ``ioctl(4, ...)`` must be intercepted; for littlefs "
"``ioctl(6, ...)`` must also be intercepted. The need for others is "
"hardware dependent."
msgstr ""

#: ../../library/os.rst:317
msgid ""
"Prior to any call to ``writeblocks(block, ...)`` littlefs issues "
"``ioctl(6, block)``. This enables a device driver to erase the block "
"prior to a write if the hardware requires it. Alternatively a driver "
"might intercept ``ioctl(6, block)`` and return 0 (success). In this case "
"the driver assumes responsibility for detecting the need for erasure."
msgstr ""

#: ../../library/os.rst:323
msgid ""
"Unless otherwise stated ``ioctl(op, arg)`` can return ``None``. "
"Consequently an implementation can ignore unused values of ``op``. Where "
"``op`` is intercepted, the return value for operations 4 and 5 are as "
"detailed above. Other operations should return 0 on success and non-zero "
"for failure, with the value returned being an ``OSError`` errno code."
msgstr ""

