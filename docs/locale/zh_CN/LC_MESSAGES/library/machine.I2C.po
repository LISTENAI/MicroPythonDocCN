# SOME DESCRIPTIVE TITLE.
# Copyright (C) - The MicroPython Documentation is Copyright Â© 2014-2022,
# Damien P. George, Paul Sokolovsky, and contributors
# This file is distributed under the same license as the MicroPython
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: MicroPython 1.18\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-10 14:42+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../library/machine.I2C.rst:5
msgid "class I2C -- a two-wire serial protocol"
msgstr ""

#: ../../library/machine.I2C.rst:7
msgid ""
"I2C is a two-wire protocol for communicating between devices.  At the "
"physical level it consists of 2 wires: SCL and SDA, the clock and data "
"lines respectively."
msgstr ""

#: ../../library/machine.I2C.rst:10
msgid ""
"I2C objects are created attached to a specific bus.  They can be "
"initialised when created, or initialised later on."
msgstr ""

#: ../../library/machine.I2C.rst:13
msgid "Printing the I2C object gives you information about its configuration."
msgstr ""

#: ../../library/machine.I2C.rst:15
msgid ""
"Both hardware and software I2C implementations exist via the "
":ref:`machine.I2C <machine.I2C>` and `machine.SoftI2C` classes.  Hardware"
" I2C uses underlying hardware support of the system to perform the "
"reads/writes and is usually efficient and fast but may have restrictions "
"on which pins can be used. Software I2C is implemented by bit-banging and"
" can be used on any pin but is not as efficient.  These classes have the "
"same methods available and differ primarily in the way they are "
"constructed."
msgstr ""

#: ../../library/machine.I2C.rst:23
msgid "Example usage::"
msgstr ""

#: ../../library/machine.I2C.rst:42
msgid "Constructors"
msgstr ""

#: ../../library/machine.I2C.rst:46
msgid "Construct and return a new I2C object using the following parameters:"
msgstr ""

#: ../../library/machine.I2C.rst:48
msgid ""
"*id* identifies a particular I2C peripheral.  Allowed values for depend "
"on the particular port/board"
msgstr ""

#: ../../library/machine.I2C.rst:50 ../../library/machine.I2C.rst:64
msgid "*scl* should be a pin object specifying the pin to use for SCL."
msgstr ""

#: ../../library/machine.I2C.rst:51 ../../library/machine.I2C.rst:65
msgid "*sda* should be a pin object specifying the pin to use for SDA."
msgstr ""

#: ../../library/machine.I2C.rst:52 ../../library/machine.I2C.rst:66
msgid "*freq* should be an integer which sets the maximum frequency for SCL."
msgstr ""

#: ../../library/machine.I2C.rst:55
msgid ""
"Note that some ports/boards will have default values of *scl* and *sda* "
"that can be changed in this constructor.  Others will have fixed values "
"of *scl* and *sda* that cannot be changed."
msgstr ""

#: ../../library/machine.I2C.rst:62
msgid "Construct a new software I2C object.  The parameters are:"
msgstr ""

#: ../../library/machine.I2C.rst:68
msgid ""
"*timeout* is the maximum time in microseconds to wait for clock "
"stretching (SCL held low by another device on the bus), after which an "
"``OSError(ETIMEDOUT)`` exception is raised."
msgstr ""

#: ../../library/machine.I2C.rst:73
msgid "General Methods"
msgstr ""

#: ../../library/machine.I2C.rst:77
msgid "Initialise the I2C bus with the given arguments:"
msgstr ""

#: ../../library/machine.I2C.rst:79
msgid "*scl* is a pin object for the SCL line"
msgstr ""

#: ../../library/machine.I2C.rst:80
msgid "*sda* is a pin object for the SDA line"
msgstr ""

#: ../../library/machine.I2C.rst:81
msgid "*freq* is the SCL clock rate"
msgstr ""

#: ../../library/machine.I2C.rst:85
msgid "Turn off the I2C bus."
msgstr ""

#: ../../library/machine.I2C.rst:87
msgid "Availability: WiPy."
msgstr ""

#: ../../library/machine.I2C.rst:91
msgid ""
"Scan all I2C addresses between 0x08 and 0x77 inclusive and return a list "
"of those that respond.  A device responds if it pulls the SDA line low "
"after its address (including a write bit) is sent on the bus."
msgstr ""

#: ../../library/machine.I2C.rst:96
msgid "Primitive I2C operations"
msgstr ""

#: ../../library/machine.I2C.rst:98
msgid ""
"The following methods implement the primitive I2C controller bus "
"operations and can be combined to make any I2C transaction.  They are "
"provided if you need more control over the bus, otherwise the standard "
"methods (see below) can be used."
msgstr ""

#: ../../library/machine.I2C.rst:102
msgid "These methods are only available on the `machine.SoftI2C` class."
msgstr ""

#: ../../library/machine.I2C.rst:106
msgid ""
"Generate a START condition on the bus (SDA transitions to low while SCL "
"is high)."
msgstr ""

#: ../../library/machine.I2C.rst:110
msgid ""
"Generate a STOP condition on the bus (SDA transitions to high while SCL "
"is high)."
msgstr ""

#: ../../library/machine.I2C.rst:114
msgid ""
"Reads bytes from the bus and stores them into *buf*.  The number of bytes"
" read is the length of *buf*.  An ACK will be sent on the bus after "
"receiving all but the last byte.  After the last byte is received, if "
"*nack* is true then a NACK will be sent, otherwise an ACK will be sent "
"(and in this case the peripheral assumes more bytes are going to be read "
"in a later call)."
msgstr ""

#: ../../library/machine.I2C.rst:122
msgid ""
"Write the bytes from *buf* to the bus.  Checks that an ACK is received "
"after each byte and stops transmitting the remaining bytes if a NACK is "
"received.  The function returns the number of ACKs that were received."
msgstr ""

#: ../../library/machine.I2C.rst:127
msgid "Standard bus operations"
msgstr ""

#: ../../library/machine.I2C.rst:129
msgid ""
"The following methods implement the standard I2C controller read and "
"write operations that target a given peripheral device."
msgstr ""

#: ../../library/machine.I2C.rst:134
msgid ""
"Read *nbytes* from the peripheral specified by *addr*. If *stop* is true "
"then a STOP condition is generated at the end of the transfer. Returns a "
"`bytes` object with the data read."
msgstr ""

#: ../../library/machine.I2C.rst:140
msgid ""
"Read into *buf* from the peripheral specified by *addr*. The number of "
"bytes read will be the length of *buf*. If *stop* is true then a STOP "
"condition is generated at the end of the transfer."
msgstr ""

#: ../../library/machine.I2C.rst:144 ../../library/machine.I2C.rst:191
#: ../../library/machine.I2C.rst:200
msgid "The method returns ``None``."
msgstr ""

#: ../../library/machine.I2C.rst:148
msgid ""
"Write the bytes from *buf* to the peripheral specified by *addr*.  If a "
"NACK is received following the write of a byte from *buf* then the "
"remaining bytes are not sent.  If *stop* is true then a STOP condition is"
" generated at the end of the transfer, even if a NACK is received. The "
"function returns the number of ACKs that were received."
msgstr ""

#: ../../library/machine.I2C.rst:156
msgid ""
"Write the bytes contained in *vector* to the peripheral specified by "
"*addr*. *vector* should be a tuple or list of objects with the buffer "
"protocol. The *addr* is sent once and then the bytes from each object in "
"*vector* are written out sequentially.  The objects in *vector* may be "
"zero bytes in length in which case they don't contribute to the output."
msgstr ""

#: ../../library/machine.I2C.rst:162
msgid ""
"If a NACK is received following the write of a byte from one of the "
"objects in *vector* then the remaining bytes, and any remaining objects, "
"are not sent.  If *stop* is true then a STOP condition is generated at "
"the end of the transfer, even if a NACK is received.  The function "
"returns the number of ACKs that were received."
msgstr ""

#: ../../library/machine.I2C.rst:169
msgid "Memory operations"
msgstr ""

#: ../../library/machine.I2C.rst:171
msgid ""
"Some I2C devices act as a memory device (or set of registers) that can be"
" read from and written to.  In this case there are two addresses "
"associated with an I2C transaction: the peripheral address and the memory"
" address.  The following methods are convenience functions to communicate"
" with such devices."
msgstr ""

#: ../../library/machine.I2C.rst:178
msgid ""
"Read *nbytes* from the peripheral specified by *addr* starting from the "
"memory address specified by *memaddr*. The argument *addrsize* specifies "
"the address size in bits. Returns a `bytes` object with the data read."
msgstr ""

#: ../../library/machine.I2C.rst:185
msgid ""
"Read into *buf* from the peripheral specified by *addr* starting from the"
" memory address specified by *memaddr*.  The number of bytes read is the "
"length of *buf*. The argument *addrsize* specifies the address size in "
"bits (on ESP8266 this argument is not recognised and the address size is "
"always 8 bits)."
msgstr ""

#: ../../library/machine.I2C.rst:195
msgid ""
"Write *buf* to the peripheral specified by *addr* starting from the "
"memory address specified by *memaddr*. The argument *addrsize* specifies "
"the address size in bits (on ESP8266 this argument is not recognised and "
"the address size is always 8 bits)."
msgstr ""

