# SOME DESCRIPTIVE TITLE.
# Copyright (C) - The MicroPython Documentation is Copyright Â© 2014-2022,
# Damien P. George, Paul Sokolovsky, and contributors
# This file is distributed under the same license as the MicroPython
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: MicroPython 1.18\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-10 14:42+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../library/pyb.rst:2
msgid ":mod:`pyb` --- functions related to the board"
msgstr ""

#: ../../library/pyb.rst:7
msgid "The ``pyb`` module contains specific functions related to the board."
msgstr ""

#: ../../library/pyb.rst:10
msgid "Time related functions"
msgstr ""

#: ../../library/pyb.rst:14
msgid "Delay for the given number of milliseconds."
msgstr ""

#: ../../library/pyb.rst:18
msgid "Delay for the given number of microseconds."
msgstr ""

#: ../../library/pyb.rst:22
msgid "Returns the number of milliseconds since the board was last reset."
msgstr ""

#: ../../library/pyb.rst:24
msgid ""
"The result is always a MicroPython smallint (31-bit signed number), so "
"after 2^30 milliseconds (about 12.4 days) this will start to return "
"negative numbers."
msgstr ""

#: ../../library/pyb.rst:28
msgid ""
"Note that if :meth:`pyb.stop()` is issued the hardware counter supporting"
" this function will pause for the duration of the \"sleeping\" state. "
"This will affect the outcome of :meth:`pyb.elapsed_millis()`."
msgstr ""

#: ../../library/pyb.rst:34
msgid "Returns the number of microseconds since the board was last reset."
msgstr ""

#: ../../library/pyb.rst:36
msgid ""
"The result is always a MicroPython smallint (31-bit signed number), so "
"after 2^30 microseconds (about 17.8 minutes) this will start to return "
"negative numbers."
msgstr ""

#: ../../library/pyb.rst:40
msgid ""
"Note that if :meth:`pyb.stop()` is issued the hardware counter supporting"
" this function will pause for the duration of the \"sleeping\" state. "
"This will affect the outcome of :meth:`pyb.elapsed_micros()`."
msgstr ""

#: ../../library/pyb.rst:46
msgid "Returns the number of milliseconds which have elapsed since ``start``."
msgstr ""

#: ../../library/pyb.rst:48
msgid ""
"This function takes care of counter wrap, and always returns a positive "
"number. This means it can be used to measure periods up to about 12.4 "
"days."
msgstr ""

#: ../../library/pyb.rst:51 ../../library/pyb.rst:64
msgid "Example::"
msgstr ""

#: ../../library/pyb.rst:59
msgid "Returns the number of microseconds which have elapsed since ``start``."
msgstr ""

#: ../../library/pyb.rst:61
msgid ""
"This function takes care of counter wrap, and always returns a positive "
"number. This means it can be used to measure periods up to about 17.8 "
"minutes."
msgstr ""

#: ../../library/pyb.rst:72
msgid "Reset related functions"
msgstr ""

#: ../../library/pyb.rst:76
msgid ""
"Resets the pyboard in a manner similar to pushing the external RESET "
"button."
msgstr ""

#: ../../library/pyb.rst:81
msgid "Activate the bootloader without BOOT\\* pins."
msgstr ""

#: ../../library/pyb.rst:85
msgid ""
"Enable or disable hard-fault debugging.  A hard-fault is when there is a "
"fatal error in the underlying system, like an invalid memory access."
msgstr ""

#: ../../library/pyb.rst:88
msgid ""
"If the *value* argument is ``False`` then the board will automatically "
"reset if there is a hard fault."
msgstr ""

#: ../../library/pyb.rst:91
msgid ""
"If *value* is ``True`` then, when the board has a hard fault, it will "
"print the registers and the stack trace, and then cycle the LEDs "
"indefinitely."
msgstr ""

#: ../../library/pyb.rst:94
msgid "The default value is disabled, i.e. to automatically reset."
msgstr ""

#: ../../library/pyb.rst:97
msgid "Interrupt related functions"
msgstr ""

#: ../../library/pyb.rst:101
msgid ""
"Disable interrupt requests. Returns the previous IRQ state: "
"``False``/``True`` for disabled/enabled IRQs respectively.  This return "
"value can be passed to enable_irq to restore the IRQ to its original "
"state."
msgstr ""

#: ../../library/pyb.rst:108
msgid ""
"Enable interrupt requests. If ``state`` is ``True`` (the default value) "
"then IRQs are enabled. If ``state`` is ``False`` then IRQs are disabled."
"  The most common use of this function is to pass it the value returned "
"by ``disable_irq`` to exit a critical section."
msgstr ""

#: ../../library/pyb.rst:115
msgid "Power related functions"
msgstr ""

#: ../../library/pyb.rst:119
msgid ""
"If given no arguments, returns a tuple of clock frequencies: (sysclk, "
"hclk, pclk1, pclk2). These correspond to:"
msgstr ""

#: ../../library/pyb.rst:123
msgid "sysclk: frequency of the CPU"
msgstr ""

#: ../../library/pyb.rst:124
msgid "hclk: frequency of the AHB bus, core memory and DMA"
msgstr ""

#: ../../library/pyb.rst:125
msgid "pclk1: frequency of the APB1 bus"
msgstr ""

#: ../../library/pyb.rst:126
msgid "pclk2: frequency of the APB2 bus"
msgstr ""

#: ../../library/pyb.rst:128
msgid ""
"If given any arguments then the function sets the frequency of the CPU, "
"and the buses if additional arguments are given.  Frequencies are given "
"in Hz.  Eg freq(120000000) sets sysclk (the CPU frequency) to 120MHz.  "
"Note that not all values are supported and the largest supported "
"frequency not greater than the given value will be selected."
msgstr ""

#: ../../library/pyb.rst:134
msgid ""
"Supported sysclk frequencies are (in MHz): 8, 16, 24, 30, 32, 36, 40, 42,"
" 48, 54, 56, 60, 64, 72, 84, 96, 108, 120, 144, 168."
msgstr ""

#: ../../library/pyb.rst:137
msgid ""
"The maximum frequency of hclk is 168MHz, of pclk1 is 42MHz, and of pclk2 "
"is 84MHz.  Be sure not to set frequencies above these values."
msgstr ""

#: ../../library/pyb.rst:140
msgid ""
"The hclk, pclk1 and pclk2 frequencies are derived from the sysclk "
"frequency using a prescaler (divider).  Supported prescalers for hclk "
"are: 1, 2, 4, 8, 16, 64, 128, 256, 512.  Supported prescalers for pclk1 "
"and pclk2 are: 1, 2, 4, 8.  A prescaler will be chosen to best match the "
"requested frequency."
msgstr ""

#: ../../library/pyb.rst:145
msgid ""
"A sysclk frequency of 8MHz uses the HSE (external crystal) directly and "
"16MHz uses the HSI (internal oscillator) directly.  The higher "
"frequencies use the HSE to drive the PLL (phase locked loop), and then "
"use the output of the PLL."
msgstr ""

#: ../../library/pyb.rst:150
msgid ""
"Note that if you change the frequency while the USB is enabled then the "
"USB may become unreliable.  It is best to change the frequency in "
"boot.py, before the USB peripheral is started.  Also note that sysclk "
"frequencies below 36MHz do not allow the USB to function correctly."
msgstr ""

#: ../../library/pyb.rst:157
msgid "Wait for an internal or external interrupt."
msgstr ""

#: ../../library/pyb.rst:159
msgid ""
"This executes a ``wfi`` instruction which reduces power consumption of "
"the MCU until any interrupt occurs (be it internal or external), at which"
" point execution continues.  Note that the system-tick interrupt occurs "
"once every millisecond (1000Hz) so this function will block for at most "
"1ms."
msgstr ""

#: ../../library/pyb.rst:167
msgid "Put the pyboard in a \"sleeping\" state."
msgstr ""

#: ../../library/pyb.rst:169
msgid ""
"This reduces power consumption to less than 500 uA.  To wake from this "
"sleep state requires an external interrupt or a real-time-clock event. "
"Upon waking execution continues where it left off."
msgstr ""

#: ../../library/pyb.rst:173 ../../library/pyb.rst:184
msgid "See :meth:`rtc.wakeup` to configure a real-time-clock wakeup event."
msgstr ""

#: ../../library/pyb.rst:177
msgid "Put the pyboard into a \"deep sleep\" state."
msgstr ""

#: ../../library/pyb.rst:179
msgid ""
"This reduces power consumption to less than 50 uA.  To wake from this "
"sleep state requires a real-time-clock event, or an external interrupt on"
" X1 (PA0=WKUP) or X18 (PC13=TAMP1). Upon waking the system undergoes a "
"hard reset."
msgstr ""

#: ../../library/pyb.rst:187
msgid "Miscellaneous functions"
msgstr ""

#: ../../library/pyb.rst:191
msgid "Return True if USB is connected as a serial device, False otherwise."
msgstr ""

#: ../../library/pyb.rst:193
msgid "This function is deprecated.  Use pyb.USB_VCP().isconnected() instead."
msgstr ""

#: ../../library/pyb.rst:197
msgid ""
"Takes a 4-tuple (or list) and sends it to the USB host (the PC) to signal"
" a HID mouse-motion event."
msgstr ""

#: ../../library/pyb.rst:200
msgid "This function is deprecated.  Use :meth:`pyb.USB_HID.send()` instead."
msgstr ""

#: ../../library/pyb.rst:204
msgid "Print out lots of information about the board."
msgstr ""

#: ../../library/pyb.rst:208
msgid ""
"Set the filename of the main script to run after boot.py is finished.  If"
" this function is not called then the default file main.py will be "
"executed."
msgstr ""

#: ../../library/pyb.rst:211
msgid "It only makes sense to call this function from within boot.py."
msgstr ""

#: ../../library/pyb.rst:215
msgid ""
"This function is deprecated. Mounting and unmounting devices should be "
"performed by :meth:`os.mount` and :meth:`os.umount` instead."
msgstr ""

#: ../../library/pyb.rst:218
msgid ""
"Mount a block device and make it available as part of the filesystem. "
"``device`` must be an object that provides the block protocol. (The "
"following is also deprecated. See :class:`os.AbstractBlockDev` for the "
"correct way to create a block device.)"
msgstr ""

#: ../../library/pyb.rst:223
msgid "``readblocks(self, blocknum, buf)``"
msgstr ""

#: ../../library/pyb.rst:224
msgid "``writeblocks(self, blocknum, buf)`` (optional)"
msgstr ""

#: ../../library/pyb.rst:225
msgid "``count(self)``"
msgstr ""

#: ../../library/pyb.rst:226
msgid "``sync(self)`` (optional)"
msgstr ""

#: ../../library/pyb.rst:228
msgid ""
"``readblocks`` and ``writeblocks`` should copy data between ``buf`` and "
"the block device, starting from block number ``blocknum`` on the device. "
"``buf`` will be a bytearray with length a multiple of 512.  If "
"``writeblocks`` is not defined then the device is mounted read-only. The "
"return value of these two functions is ignored."
msgstr ""

#: ../../library/pyb.rst:234
msgid ""
"``count`` should return the number of blocks available on the device. "
"``sync``, if implemented, should sync the data on the device."
msgstr ""

#: ../../library/pyb.rst:237
msgid ""
"The parameter ``mountpoint`` is the location in the root of the "
"filesystem to mount the device.  It must begin with a forward-slash."
msgstr ""

#: ../../library/pyb.rst:240
msgid ""
"If ``readonly`` is ``True``, then the device is mounted read-only, "
"otherwise it is mounted read-write."
msgstr ""

#: ../../library/pyb.rst:243
msgid ""
"If ``mkfs`` is ``True``, then a new filesystem is created if one does not"
" already exist."
msgstr ""

#: ../../library/pyb.rst:248
msgid "Get or set the UART object where the REPL is repeated on."
msgstr ""

#: ../../library/pyb.rst:252
msgid "Return a 30-bit hardware generated random number."
msgstr ""

#: ../../library/pyb.rst:256
msgid "Sync all file systems."
msgstr ""

#: ../../library/pyb.rst:260
msgid "Returns a string of 12 bytes (96 bits), which is the unique ID of the MCU."
msgstr ""

#: ../../library/pyb.rst:264
msgid "If called with no arguments, return the current USB mode as a string."
msgstr ""

#: ../../library/pyb.rst:266
msgid ""
"If called with *modestr* provided, attempts to configure the USB mode. "
"The following values of *modestr* are understood:"
msgstr ""

#: ../../library/pyb.rst:269
msgid "``None``: disables USB"
msgstr ""

#: ../../library/pyb.rst:270
msgid "``'VCP'``: enable with VCP (Virtual COM Port) interface"
msgstr ""

#: ../../library/pyb.rst:271
msgid "``'MSC'``: enable with MSC (mass storage device class) interface"
msgstr ""

#: ../../library/pyb.rst:272
msgid "``'VCP+MSC'``: enable with VCP and MSC"
msgstr ""

#: ../../library/pyb.rst:273
msgid "``'VCP+HID'``: enable with VCP and HID (human interface device)"
msgstr ""

#: ../../library/pyb.rst:274
msgid ""
"``'VCP+MSC+HID'``: enabled with VCP, MSC and HID (only available on PYBD "
"boards)"
msgstr ""

#: ../../library/pyb.rst:276
msgid ""
"For backwards compatibility, ``'CDC'`` is understood to mean ``'VCP'`` "
"(and similarly for ``'CDC+MSC'`` and ``'CDC+HID'``)."
msgstr ""

#: ../../library/pyb.rst:279
msgid ""
"The *port* parameter should be an integer (0, 1, ...) and selects which "
"USB port to use if the board supports multiple ports.  A value of -1 uses"
" the default or automatically selected port."
msgstr ""

#: ../../library/pyb.rst:283
msgid ""
"The *vid* and *pid* parameters allow you to specify the VID (vendor id) "
"and PID (product id).  A *pid* value of -1 will select a PID based on the"
" value of *modestr*."
msgstr ""

#: ../../library/pyb.rst:287
msgid ""
"If enabling MSC mode, the *msc* parameter can be used to specify a list "
"of SCSI LUNs to expose on the mass storage interface.  For example "
"``msc=(pyb.Flash(), pyb.SDCard())``."
msgstr ""

#: ../../library/pyb.rst:291
msgid ""
"If enabling HID mode, you may also specify the HID details by passing the"
" *hid* keyword parameter.  It takes a tuple of (subclass, protocol, max "
"packet length, polling interval, report descriptor).  By default it will "
"set appropriate values for a USB mouse.  There is also a "
"``pyb.hid_keyboard`` constant, which is an appropriate tuple for a USB "
"keyboard."
msgstr ""

#: ../../library/pyb.rst:298
msgid ""
"The *high_speed* parameter, when set to ``True``, enables USB HS mode if "
"it is supported by the hardware."
msgstr ""

#: ../../library/pyb.rst:302
msgid "Classes"
msgstr ""

