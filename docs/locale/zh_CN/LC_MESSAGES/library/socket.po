# SOME DESCRIPTIVE TITLE.
# Copyright (C) - The MicroPython Documentation is Copyright Â© 2014-2022,
# Damien P. George, Paul Sokolovsky, and contributors
# This file is distributed under the same license as the MicroPython
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: MicroPython 1.18\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-10 14:42+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../library/socket.rst:3
msgid ":mod:`socket` -- socket module"
msgstr ""

#: ../../library/socket.rst:8
msgid "|see_cpython_module| :mod:`python:socket`."
msgstr ""

#: ../../library/socket.rst:10
msgid "This module provides access to the BSD socket interface."
msgstr ""

#: ../../library/socket.rst:12 ../../library/socket.rst:109
#: ../../library/socket.rst:278 ../../library/socket.rst:302
#: ../../library/socket.rst:308 ../../library/socket.rst:349
msgid "Difference to CPython"
msgstr ""

#: ../../library/socket.rst:15
msgid ""
"For efficiency and consistency, socket objects in MicroPython implement a"
" `stream` (file-like) interface directly. In CPython, you need to convert"
" a socket to a file-like object using `makefile()` method. This method is"
" still supported by MicroPython (but is a no-op), so where compatibility "
"with CPython matters, be sure to use it."
msgstr ""

#: ../../library/socket.rst:22
msgid "Socket address format(s)"
msgstr ""

#: ../../library/socket.rst:24
msgid ""
"The native socket address format of the ``socket`` module is an opaque "
"data type returned by `getaddrinfo` function, which must be used to "
"resolve textual address (including numeric addresses)::"
msgstr ""

#: ../../library/socket.rst:34
msgid ""
"Using `getaddrinfo` is the most efficient (both in terms of memory and "
"processing power) and portable way to work with addresses."
msgstr ""

#: ../../library/socket.rst:37
msgid ""
"However, ``socket`` module (note the difference with native MicroPython "
"``socket`` module described here) provides CPython-compatible way to "
"specify addresses using tuples, as described below. Note that depending "
"on a :term:`MicroPython port`, ``socket`` module can be builtin or need "
"to be installed from `micropython-lib` (as in the case of "
":term:`MicroPython Unix port`), and some ports still accept only numeric "
"addresses in the tuple format, and require to use `getaddrinfo` function "
"to resolve domain names."
msgstr ""

#: ../../library/socket.rst:45
msgid "Summing up:"
msgstr ""

#: ../../library/socket.rst:47
msgid "Always use `getaddrinfo` when writing portable applications."
msgstr ""

#: ../../library/socket.rst:48
msgid ""
"Tuple addresses described below can be used as a shortcut for quick hacks"
" and interactive use, if your port supports them."
msgstr ""

#: ../../library/socket.rst:51
msgid "Tuple address format for ``socket`` module:"
msgstr ""

#: ../../library/socket.rst:53
msgid ""
"IPv4: *(ipv4_address, port)*, where *ipv4_address* is a string with dot-"
"notation numeric IPv4 address, e.g. ``\"8.8.8.8\"``, and *port* is and "
"integer port number in the range 1-65535. Note the domain names are not "
"accepted as *ipv4_address*, they should be resolved first using "
"`socket.getaddrinfo()`."
msgstr ""

#: ../../library/socket.rst:58
msgid ""
"IPv6: *(ipv6_address, port, flowinfo, scopeid)*, where *ipv6_address* is "
"a string with colon-notation numeric IPv6 address, e.g. "
"``\"2001:db8::1\"``, and *port* is an integer port number in the range "
"1-65535. *flowinfo* must be 0. *scopeid* is the interface scope "
"identifier for link-local addresses. Note the domain names are not "
"accepted as *ipv6_address*, they should be resolved first using "
"`socket.getaddrinfo()`. Availability of IPv6 support depends on a "
":term:`MicroPython port`."
msgstr ""

#: ../../library/socket.rst:67
msgid "Functions"
msgstr ""

#: ../../library/socket.rst:71
msgid ""
"Create a new socket using the given address family, socket type and "
"protocol number. Note that specifying *proto* in most cases is not "
"required (and not recommended, as some MicroPython ports may omit "
"``IPPROTO_*`` constants). Instead, *type* argument will select needed "
"protocol automatically::"
msgstr ""

#: ../../library/socket.rst:84
msgid ""
"Translate the host/port argument into a sequence of 5-tuples that contain"
" all the necessary arguments for creating a socket connected to that "
"service. Arguments *af*, *type*, and *proto* (which have the same meaning"
" as for the `socket()` function) can be used to filter which kind of "
"addresses are returned. If a parameter is not specified or zero, all "
"combinations of addresses can be returned (requiring filtering on the "
"user side)."
msgstr ""

#: ../../library/socket.rst:91
msgid "The resulting list of 5-tuples has the following structure::"
msgstr ""

#: ../../library/socket.rst:95
msgid "The following example shows how to connect to a given url::"
msgstr ""

#: ../../library/socket.rst:102
msgid "Recommended use of filtering params::"
msgstr ""

#: ../../library/socket.rst:112
msgid ""
"CPython raises a ``socket.gaierror`` exception (`OSError` subclass) in "
"case of error in this function. MicroPython doesn't have "
"``socket.gaierror`` and raises OSError directly. Note that error numbers "
"of `getaddrinfo()` form a separate namespace and may not match error "
"numbers from the :mod:`errno` module. To distinguish `getaddrinfo()` "
"errors, they are represented by negative numbers, whereas standard system"
" errors are positive numbers (error numbers are accessible using "
"``e.args[0]`` property from an exception object). The use of negative "
"values is a provisional detail which may change in the future."
msgstr ""

#: ../../library/socket.rst:124
msgid ""
"Convert a binary network address *bin_addr* of the given address family "
"*af* to a textual representation::"
msgstr ""

#: ../../library/socket.rst:132
msgid ""
"Convert a textual network address *txt_addr* of the given address family "
"*af* to a binary representation::"
msgstr ""

#: ../../library/socket.rst:139
msgid "Constants"
msgstr ""

#: ../../library/socket.rst:144
msgid ""
"Address family types. Availability depends on a particular "
":term:`MicroPython port`."
msgstr ""

#: ../../library/socket.rst:149
msgid "Socket types."
msgstr ""

#: ../../library/socket.rst:154
msgid ""
"IP protocol numbers. Availability depends on a particular "
":term:`MicroPython port`. Note that you don't need to specify these in a "
"call to `socket.socket()`, because `SOCK_STREAM` socket type "
"automatically selects `IPPROTO_TCP`, and `SOCK_DGRAM` - `IPPROTO_UDP`. "
"Thus, the only real use of these constants is as an argument to "
"`setsockopt()`."
msgstr ""

#: ../../library/socket.rst:162
msgid ""
"Socket option levels (an argument to `setsockopt()`). The exact inventory"
" depends on a :term:`MicroPython port`."
msgstr ""

#: ../../library/socket.rst:167
msgid ""
"Socket options (an argument to `setsockopt()`). The exact inventory "
"depends on a :term:`MicroPython port`."
msgstr ""

#: ../../library/socket.rst:170
msgid "Constants specific to WiPy:"
msgstr ""

#: ../../library/socket.rst:174
msgid "Special protocol value to create SSL-compatible socket."
msgstr ""

#: ../../library/socket.rst:177
msgid "class socket"
msgstr ""

#: ../../library/socket.rst:180
msgid "Methods"
msgstr ""

#: ../../library/socket.rst:184
msgid ""
"Mark the socket closed and release all resources. Once that happens, all "
"future operations on the socket object will fail. The remote end will "
"receive EOF indication if supported by protocol."
msgstr ""

#: ../../library/socket.rst:188
msgid ""
"Sockets are automatically closed when they are garbage-collected, but it "
"is recommended to `close()` them explicitly as soon you finished working "
"with them."
msgstr ""

#: ../../library/socket.rst:193
msgid "Bind the socket to *address*. The socket must not already be bound."
msgstr ""

#: ../../library/socket.rst:197
msgid ""
"Enable a server to accept connections. If *backlog* is specified, it must"
" be at least 0 (if it's lower, it will be set to 0); and specifies the "
"number of unaccepted connections that the system will allow before "
"refusing new connections. If not specified, a default reasonable value is"
" chosen."
msgstr ""

#: ../../library/socket.rst:204
msgid ""
"Accept a connection. The socket must be bound to an address and listening"
" for connections. The return value is a pair (conn, address) where conn "
"is a new socket object usable to send and receive data on the connection,"
" and address is the address bound to the socket on the other end of the "
"connection."
msgstr ""

#: ../../library/socket.rst:211
msgid "Connect to a remote socket at *address*."
msgstr ""

#: ../../library/socket.rst:215
msgid ""
"Send data to the socket. The socket must be connected to a remote socket."
" Returns number of bytes sent, which may be smaller than the length of "
"data (\"short write\")."
msgstr ""

#: ../../library/socket.rst:221
msgid ""
"Send all data to the socket. The socket must be connected to a remote "
"socket. Unlike `send()`, this method will try to send all of data, by "
"sending data chunk by chunk consecutively."
msgstr ""

#: ../../library/socket.rst:225
msgid ""
"The behaviour of this method on non-blocking sockets is undefined. Due to"
" this, on MicroPython, it's recommended to use `write()` method instead, "
"which has the same \"no short writes\" policy for blocking sockets, and "
"will return number of bytes sent on non-blocking sockets."
msgstr ""

#: ../../library/socket.rst:232
msgid ""
"Receive data from the socket. The return value is a bytes object "
"representing the data received. The maximum amount of data to be received"
" at once is specified by bufsize."
msgstr ""

#: ../../library/socket.rst:237
msgid ""
"Send data to the socket. The socket should not be connected to a remote "
"socket, since the destination socket is specified by *address*."
msgstr ""

#: ../../library/socket.rst:242
msgid ""
"Receive data from the socket. The return value is a pair *(bytes, "
"address)* where *bytes* is a bytes object representing the data received "
"and *address* is the address of the socket sending the data."
msgstr ""

#: ../../library/socket.rst:248
msgid ""
"Set the value of the given socket option. The needed symbolic constants "
"are defined in the socket module (SO_* etc.). The *value* can be an "
"integer or a bytes-like object representing a buffer."
msgstr ""

#: ../../library/socket.rst:254
msgid "**Note**: Not every port supports this method, see below."
msgstr ""

#: ../../library/socket.rst:256
msgid ""
"Set a timeout on blocking socket operations. The value argument can be a "
"nonnegative floating point number expressing seconds, or None. If a non-"
"zero value is given, subsequent socket operations will raise an `OSError`"
" exception if the timeout period value has elapsed before the operation "
"has completed. If zero is given, the socket is put in non-blocking mode. "
"If None is given, the socket is put in blocking mode."
msgstr ""

#: ../../library/socket.rst:262
msgid ""
"Not every :term:`MicroPython port` supports this method. A more portable "
"and generic solution is to use `select.poll` object. This allows to wait "
"on multiple objects at the same time (and not just on sockets, but on "
"generic `stream` objects which support polling). Example::"
msgstr ""

#: ../../library/socket.rst:281
msgid ""
"CPython raises a ``socket.timeout`` exception in case of timeout, which "
"is an `OSError` subclass. MicroPython raises an OSError directly instead."
" If you use ``except OSError:`` to catch the exception, your code will "
"work both in MicroPython and CPython."
msgstr ""

#: ../../library/socket.rst:288
msgid ""
"Set blocking or non-blocking mode of the socket: if flag is false, the "
"socket is set to non-blocking, else to blocking mode."
msgstr ""

#: ../../library/socket.rst:291
msgid "This method is a shorthand for certain `settimeout()` calls:"
msgstr ""

#: ../../library/socket.rst:293
msgid "``sock.setblocking(True)`` is equivalent to ``sock.settimeout(None)``"
msgstr ""

#: ../../library/socket.rst:294
msgid "``sock.setblocking(False)`` is equivalent to ``sock.settimeout(0)``"
msgstr ""

#: ../../library/socket.rst:298
msgid ""
"Return a file object associated with the socket. The exact returned type "
"depends on the arguments given to makefile(). The support is limited to "
"binary modes only ('rb', 'wb', and 'rwb'). CPython's arguments: "
"*encoding*, *errors* and *newline* are not supported."
msgstr ""

#: ../../library/socket.rst:305
msgid ""
"As MicroPython doesn't support buffered streams, values of *buffering* "
"parameter is ignored and treated as if it was 0 (unbuffered)."
msgstr ""

#: ../../library/socket.rst:311
msgid ""
"Closing the file object returned by makefile() WILL close the original "
"socket as well."
msgstr ""

#: ../../library/socket.rst:316
msgid ""
"Read up to size bytes from the socket. Return a bytes object. If *size* "
"is not given, it reads all data available from the socket until EOF; as "
"such the method will not return until the socket is closed. This function"
" tries to read as much data as requested (no \"short reads\"). This may "
"be not possible with non-blocking socket though, and then less data will "
"be returned."
msgstr ""

#: ../../library/socket.rst:324
msgid ""
"Read bytes into the *buf*.  If *nbytes* is specified then read at most "
"that many bytes.  Otherwise, read at most *len(buf)* bytes. Just as "
"`read()`, this method follows \"no short reads\" policy."
msgstr ""

#: ../../library/socket.rst:328
msgid "Return value: number of bytes read and stored into *buf*."
msgstr ""

#: ../../library/socket.rst:332
msgid "Read a line, ending in a newline character."
msgstr ""

#: ../../library/socket.rst:334
msgid "Return value: the line read."
msgstr ""

#: ../../library/socket.rst:338
msgid ""
"Write the buffer of bytes to the socket. This function will try to write "
"all data to a socket (no \"short writes\"). This may be not possible with"
" a non-blocking socket though, and returned value will be less than the "
"length of *buf*."
msgstr ""

#: ../../library/socket.rst:343
msgid "Return value: number of bytes written."
msgstr ""

#: ../../library/socket.rst:347
msgid "MicroPython does NOT have this exception."
msgstr ""

#: ../../library/socket.rst:352
msgid ""
"CPython used to have a ``socket.error`` exception which is now "
"deprecated, and is an alias of `OSError`. In MicroPython, use `OSError` "
"directly."
msgstr ""

