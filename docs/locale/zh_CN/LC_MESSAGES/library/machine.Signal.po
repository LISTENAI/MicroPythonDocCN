# SOME DESCRIPTIVE TITLE.
# Copyright (C) - The MicroPython Documentation is Copyright Â© 2014-2022,
# Damien P. George, Paul Sokolovsky, and contributors
# This file is distributed under the same license as the MicroPython
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: MicroPython 1.18\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-10 14:42+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../library/machine.Signal.rst:5
msgid "class Signal -- control and sense external I/O devices"
msgstr ""

#: ../../library/machine.Signal.rst:7
msgid ""
"The Signal class is a simple extension of the `Pin` class. Unlike Pin, "
"which can be only in \"absolute\" 0 and 1 states, a Signal can be in "
"\"asserted\" (on) or \"deasserted\" (off) states, while being inverted "
"(active-low) or not. In other words, it adds logical inversion support to"
" Pin functionality. While this may seem a simple addition, it is exactly "
"what is needed to support wide array of simple digital devices in a way "
"portable across different boards, which is one of the major MicroPython "
"goals. Regardless of whether different users have an active-high or "
"active-low LED, a normally open or normally closed relay - you can "
"develop a single, nicely looking application which works with each of "
"them, and capture hardware configuration differences in few lines in the "
"config file of your app."
msgstr ""

#: ../../library/machine.Signal.rst:19
msgid "Example::"
msgstr ""

#: ../../library/machine.Signal.rst:46
msgid "Following is the guide when Signal vs Pin should be used:"
msgstr ""

#: ../../library/machine.Signal.rst:48
msgid ""
"Use Signal: If you want to control a simple on/off (including software "
"PWM!) devices like LEDs, multi-segment indicators, relays, buzzers, or "
"read simple binary sensors, like normally open or normally closed "
"buttons, pulled high or low, Reed switches, moisture/flame detectors, "
"etc. etc. Summing up, if you have a real physical device/sensor requiring"
" GPIO access, you likely should use a Signal."
msgstr ""

#: ../../library/machine.Signal.rst:55
msgid ""
"Use Pin: If you implement a higher-level protocol or bus to communicate "
"with more complex devices."
msgstr ""

#: ../../library/machine.Signal.rst:58
msgid ""
"The split between Pin and Signal come from the use cases above and the "
"architecture of MicroPython: Pin offers the lowest overhead, which may be"
" important when bit-banging protocols. But Signal adds additional "
"flexibility on top of Pin, at the cost of minor overhead (much smaller "
"than if you implemented active-high vs active-low device differences in "
"Python manually!). Also, Pin is a low-level object which needs to be "
"implemented for each support board, while Signal is a high-level object "
"which comes for free once Pin is implemented."
msgstr ""

#: ../../library/machine.Signal.rst:67
msgid ""
"If in doubt, give the Signal a try! Once again, it is offered to save "
"developers from the need to handle unexciting differences like active-low"
" vs active-high signals, and allow other users to share and enjoy your "
"application, instead of being frustrated by the fact that it doesn't work"
" for them simply because their LEDs or relays are wired in a slightly "
"different way."
msgstr ""

#: ../../library/machine.Signal.rst:75
msgid "Constructors"
msgstr ""

#: ../../library/machine.Signal.rst:80
msgid "Create a Signal object. There're two ways to create it:"
msgstr ""

#: ../../library/machine.Signal.rst:82
msgid ""
"By wrapping existing Pin object - universal method which works for any "
"board."
msgstr ""

#: ../../library/machine.Signal.rst:84
msgid ""
"By passing required Pin parameters directly to Signal constructor, "
"skipping the need to create intermediate Pin object. Available on many, "
"but not all boards."
msgstr ""

#: ../../library/machine.Signal.rst:88
msgid "The arguments are:"
msgstr ""

#: ../../library/machine.Signal.rst:90
msgid "``pin_obj`` is existing Pin object."
msgstr ""

#: ../../library/machine.Signal.rst:92
msgid ""
"``pin_arguments`` are the same arguments as can be passed to Pin "
"constructor."
msgstr ""

#: ../../library/machine.Signal.rst:94
msgid "``invert`` - if True, the signal will be inverted (active low)."
msgstr ""

#: ../../library/machine.Signal.rst:97
msgid "Methods"
msgstr ""

#: ../../library/machine.Signal.rst:101
msgid ""
"This method allows to set and get the value of the signal, depending on "
"whether the argument ``x`` is supplied or not."
msgstr ""

#: ../../library/machine.Signal.rst:104
msgid ""
"If the argument is omitted then this method gets the signal level, 1 "
"meaning signal is asserted (active) and 0 - signal inactive."
msgstr ""

#: ../../library/machine.Signal.rst:107
msgid ""
"If the argument is supplied then this method sets the signal level. The "
"argument ``x`` can be anything that converts to a boolean. If it converts"
" to ``True``, the signal is active, otherwise it is inactive."
msgstr ""

#: ../../library/machine.Signal.rst:111
msgid ""
"Correspondence between signal being active and actual logic level on the "
"underlying pin depends on whether signal is inverted (active-low) or not."
" For non-inverted signal, active status corresponds to logical 1, "
"inactive - to logical 0. For inverted/active-low signal, active status "
"corresponds to logical 0, while inactive - to logical 1."
msgstr ""

#: ../../library/machine.Signal.rst:119
msgid "Activate signal."
msgstr ""

#: ../../library/machine.Signal.rst:123
msgid "Deactivate signal."
msgstr ""

