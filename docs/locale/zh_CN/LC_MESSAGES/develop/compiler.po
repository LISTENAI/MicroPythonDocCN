# SOME DESCRIPTIVE TITLE.
# Copyright (C) - The MicroPython Documentation is Copyright Â© 2014-2022,
# Damien P. George, Paul Sokolovsky, and contributors
# This file is distributed under the same license as the MicroPython
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: MicroPython 1.18\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-10 14:42+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../develop/compiler.rst:4
msgid "The Compiler"
msgstr ""

#: ../../develop/compiler.rst:6
msgid "The compilation process in MicroPython involves the following steps:"
msgstr ""

#: ../../develop/compiler.rst:8
msgid ""
"The lexer converts the stream of text that makes up a MicroPython program"
" into tokens."
msgstr ""

#: ../../develop/compiler.rst:9
msgid "The parser then converts the tokens into an abstract syntax (parse tree)."
msgstr ""

#: ../../develop/compiler.rst:10
msgid "Then bytecode or native code is emitted based on the parse tree."
msgstr ""

#: ../../develop/compiler.rst:12
msgid ""
"For purposes of this discussion we are going to add a simple language "
"feature ``add1`` that can be use in Python as:"
msgstr ""

#: ../../develop/compiler.rst:21
msgid "The ``add1`` statement takes an integer as argument and adds ``1`` to it."
msgstr ""

#: ../../develop/compiler.rst:24
msgid "Adding a grammar rule"
msgstr ""

#: ../../develop/compiler.rst:26
msgid ""
"MicroPython's grammar is based on the `CPython grammar "
"<https://docs.python.org/3.5/reference/grammar.html>`_ and is defined in "
"`py/grammar.h "
"<https://github.com/micropython/micropython/blob/master/py/grammar.h>`_. "
"This grammar is what is used to parse MicroPython source files."
msgstr ""

#: ../../develop/compiler.rst:30
msgid ""
"There are two macros you need to know to define a grammar rule: "
"``DEF_RULE`` and ``DEF_RULE_NC``. ``DEF_RULE`` allows you to define a "
"rule with an associated compile function, while ``DEF_RULE_NC`` has no "
"compile (NC) function for it."
msgstr ""

#: ../../develop/compiler.rst:34
msgid ""
"A simple grammar definition with a compile function for our new ``add1`` "
"statement looks like the following:"
msgstr ""

#: ../../develop/compiler.rst:41
msgid ""
"The second argument ``c(add1_stmt)`` is the corresponding compile "
"function that should be implemented in ``py/compile.c`` to turn this rule"
" into executable code."
msgstr ""

#: ../../develop/compiler.rst:44
msgid ""
"The third required argument can be ``or`` or ``and``. This specifies the "
"number of nodes associated with a statement. For example, in this case, "
"our ``add1`` statement is similar to ADD1 in assembly language. It takes "
"one numeric argument. Therefore, the ``add1_stmt`` has two nodes "
"associated with it. One node is for the statement itself, i.e the literal"
" ``add1`` corresponding to ``KW_ADD1``, and the other for its argument, a"
" ``testlist`` rule which is the top-level expression rule."
msgstr ""

#: ../../develop/compiler.rst:51
msgid ""
"The ``add1`` rule here is just an example and not part of the standard "
"MicroPython grammar."
msgstr ""

#: ../../develop/compiler.rst:54
msgid ""
"The fourth argument in this example is the token associated with the "
"rule, ``KW_ADD1``. This token should be defined in the lexer by editing "
"``py/lexer.h``."
msgstr ""

#: ../../develop/compiler.rst:57
msgid ""
"Defining the same rule without a compile function is achieved by using "
"the ``DEF_RULE_NC`` macro and omitting the compile function argument:"
msgstr ""

#: ../../develop/compiler.rst:64
msgid ""
"The remaining arguments take on the same meaning. A rule without a "
"compile function must be handled explicitly by all rules that may have "
"this rule as a node. Such NC-rules are usually used to express sub-parts "
"of a complicated grammar structure that cannot be expressed in a single "
"rule."
msgstr ""

#: ../../develop/compiler.rst:70
msgid ""
"The macros ``DEF_RULE`` and ``DEF_RULE_NC`` take other arguments. For an "
"in-depth understanding of supported parameters, see `py/grammar.h "
"<https://github.com/micropython/micropython/blob/master/py/grammar.h>`_."
msgstr ""

#: ../../develop/compiler.rst:74
msgid "Adding a lexical token"
msgstr ""

#: ../../develop/compiler.rst:76
msgid ""
"Every rule defined in the grammar should have a token associated with it "
"that is defined in ``py/lexer.h``. Add this token by editing the "
"``_mp_token_kind_t`` enum:"
msgstr ""

#: ../../develop/compiler.rst:96
msgid "Then also edit ``py/lexer.c`` to add the new keyword literal text:"
msgstr ""

#: ../../develop/compiler.rst:115
msgid ""
"Notice the keyword is named depending on what you want it to be. For "
"consistency, maintain the naming standard accordingly."
msgstr ""

#: ../../develop/compiler.rst:119
msgid ""
"The order of these keywords in ``py/lexer.c`` must match the order of "
"tokens in the enum defined in ``py/lexer.h``."
msgstr ""

#: ../../develop/compiler.rst:123
msgid "Parsing"
msgstr ""

#: ../../develop/compiler.rst:125
msgid ""
"In the parsing stage the parser takes the tokens produced by the lexer "
"and converts them to an abstract syntax tree (AST) or *parse tree*. The "
"implementation for the parser is defined in `py/parse.c "
"<https://github.com/micropython/micropython/blob/master/py/parse.c>`_."
msgstr ""

#: ../../develop/compiler.rst:128
msgid ""
"The parser also maintains a table of constants for use in different "
"aspects of parsing, similar to what a `symbol table "
"<https://steemit.com/programming/@drifter1/writing-a-simple-compiler-on-"
"my-own-symbol-table-basic-structure>`_ does."
msgstr ""

#: ../../develop/compiler.rst:132
msgid ""
"Several optimizations like `constant folding "
"<http://compileroptimizations.com/category/constant_folding.htm>`_ on "
"integers for most operations e.g. logical, binary, unary, etc, and "
"optimizing enhancements on parenthesis around expressions are performed "
"during this phase, along with some optimizations on strings."
msgstr ""

#: ../../develop/compiler.rst:136
msgid ""
"It's worth noting that *docstrings* are discarded and not accessible to "
"the compiler. Even optimizations like `string interning "
"<https://en.wikipedia.org/wiki/String_interning>`_ are not applied to "
"*docstrings*."
msgstr ""

#: ../../develop/compiler.rst:141
msgid "Compiler passes"
msgstr ""

#: ../../develop/compiler.rst:143
msgid ""
"Like many compilers, MicroPython compiles all code to MicroPython "
"bytecode or native code. The functionality that achieves this is "
"implemented in `py/compile.c "
"<https://github.com/micropython/micropython/blob/master/py/compile.c>`_. "
"The most relevant method you should know about is this:"
msgstr ""

#: ../../develop/compiler.rst:156
msgid ""
"The compiler compiles the code in four passes: scope, stack size, code "
"size and emit. Each pass runs the same C code over the same AST data "
"structure, with different things being computed each time based on the "
"results of the previous pass."
msgstr ""

#: ../../develop/compiler.rst:161
msgid "First pass"
msgstr ""

#: ../../develop/compiler.rst:163
msgid ""
"In the first pass, the compiler learns about the known identifiers "
"(variables) and their scope, being global, local, closed over, etc. In "
"the same pass the emitter (bytecode or native code) also computes the "
"number of labels needed for the emitted code."
msgstr ""

#: ../../develop/compiler.rst:193
msgid "Second and third passes"
msgstr ""

#: ../../develop/compiler.rst:195
msgid ""
"The second and third passes involve computing the Python stack size and "
"code size for the bytecode or native code. After the third pass the code "
"size cannot change, otherwise jump labels will be incorrect."
msgstr ""

#: ../../develop/compiler.rst:215
msgid ""
"Just before pass two there is a selection for the type of code to be "
"emitted, which can either be native or bytecode."
msgstr ""

#: ../../develop/compiler.rst:237
msgid ""
"The bytecode option is the default but something unique to note for the "
"native code option is that there is another option via ``VIPER``. See the"
" :ref:`Emitting native code <emitting_native_code>` section for more "
"details on viper annotations."
msgstr ""

#: ../../develop/compiler.rst:242
msgid ""
"There is also support for *inline assembly code*, where assembly "
"instructions are written as Python function calls but are emitted "
"directly as the corresponding machine code. This assembler has only three"
" passes (scope, code size, emit) and uses a different implementation, not"
" the ``compile_scope`` function. See the `inline assembler tutorial "
"<https://docs.micropython.org/en/latest/pyboard/tutorial/assembler.html"
"#pyboard-tutorial-assembler>`_ for more details."
msgstr ""

#: ../../develop/compiler.rst:250
msgid "Fourth pass"
msgstr ""

#: ../../develop/compiler.rst:252
msgid ""
"The fourth pass emits the final code that can be executed, either "
"bytecode in the virtual machine, or native code directly by the CPU."
msgstr ""

#: ../../develop/compiler.rst:267
msgid "Emitting bytecode"
msgstr ""

#: ../../develop/compiler.rst:269
msgid ""
"Statements in Python code usually correspond to emitted bytecode, for "
"example ``a + b`` generates \"push a\" then \"push b\" then \"binary op "
"add\". Some statements do not emit anything but instead affect other "
"things like the scope of variables, for example ``global a``."
msgstr ""

#: ../../develop/compiler.rst:274
msgid ""
"The implementation of a function that emits bytecode looks similar to "
"this:"
msgstr ""

#: ../../develop/compiler.rst:282
msgid ""
"We use the unary operator expressions for an example here but the "
"implementation details are similar for other statements/expressions. The "
"method ``emit_write_bytecode_byte()`` is a wrapper around the main "
"function ``emit_get_cur_to_write_bytecode()`` that all functions must "
"call to emit bytecode."
msgstr ""

#: ../../develop/compiler.rst:290
msgid "Emitting native code"
msgstr ""

#: ../../develop/compiler.rst:292
msgid ""
"Similar to how bytecode is generated, there should be a corresponding "
"function in ``py/emitnative.c`` for each code statement:"
msgstr ""

#: ../../develop/compiler.rst:310
msgid ""
"The difference here is that we have to handle *viper typing*. Viper "
"annotations allow us to handle more than one type of variable. By default"
" all variables are Python objects, but with viper a variable can also be "
"declared as a machine-typed variable like a native integer or pointer. "
"Viper can be thought of as a superset of Python, where normal Python "
"objects are handled as usual, while native machine variables are handled "
"in an optimised way by using direct machine instructions for the "
"operations. Viper typing may break Python equivalence because, for "
"example, integers become native integers and can overflow (unlike Python "
"integers which extend automatically to arbitrary precision)."
msgstr ""

