# SOME DESCRIPTIVE TITLE.
# Copyright (C) - The MicroPython Documentation is Copyright Â© 2014-2022,
# Damien P. George, Paul Sokolovsky, and contributors
# This file is distributed under the same license as the MicroPython
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: MicroPython 1.18\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-10 14:42+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../develop/qstr.rst:4
msgid "MicroPython string interning"
msgstr ""

#: ../../develop/qstr.rst:6
msgid ""
"MicroPython uses `string interning`_ to save both RAM and ROM.  This "
"avoids having to store duplicate copies of the same string.  Primarily, "
"this applies to identifiers in your code, as something like a function or"
" variable name is very likely to appear in multiple places in the code.  "
"In MicroPython an interned string is called a QSTR (uniQue STRing)."
msgstr ""

#: ../../develop/qstr.rst:12
msgid ""
"A QSTR value (with type ``qstr``) is a index into a linked list of QSTR "
"pools. QSTRs store their length and a hash of their contents for fast "
"comparison during the de-duplication process.  All bytecode operations "
"that work with strings use a QSTR argument."
msgstr ""

#: ../../develop/qstr.rst:18
msgid "Compile-time QSTR generation"
msgstr ""

#: ../../develop/qstr.rst:20
msgid ""
"In the MicroPython C code, any strings that should be interned in the "
"final firmware are written as ``MP_QSTR_Foo``.  At compile time this will"
" evaluate to a ``qstr`` value that points to the index of ``\"Foo\"`` in "
"the QSTR pool."
msgstr ""

#: ../../develop/qstr.rst:24
msgid ""
"A multi-step process in the ``Makefile`` makes this work.  In summary "
"this process has three parts:"
msgstr ""

#: ../../develop/qstr.rst:27
msgid "Find all ``MP_QSTR_Foo`` tokens in the code."
msgstr ""

#: ../../develop/qstr.rst:29
msgid ""
"Generate a static QSTR pool containing all the string data (including "
"lengths and hashes)."
msgstr ""

#: ../../develop/qstr.rst:32
msgid ""
"Replace all ``MP_QSTR_Foo`` (via the preprocessor) with their "
"corresponding index."
msgstr ""

#: ../../develop/qstr.rst:35
msgid "``MP_QSTR_Foo`` tokens are searched for in two sources:"
msgstr ""

#: ../../develop/qstr.rst:37
msgid ""
"All files referenced in ``$(SRC_QSTR)``.  This is all C code (i.e. "
"``py``, ``extmod``, ``ports/stm32``) but not including third-party code "
"such as ``lib``."
msgstr ""

#: ../../develop/qstr.rst:41
msgid ""
"Additional ``$(QSTR_GLOBAL_DEPENDENCIES)`` (which includes "
"``mpconfig*.h``)."
msgstr ""

#: ../../develop/qstr.rst:43
msgid ""
"*Note:* ``frozen_mpy.c`` (generated by mpy-tool.py) has its own QSTR "
"generation and pool."
msgstr ""

#: ../../develop/qstr.rst:46
msgid ""
"Some additional strings that can't be expressed using the ``MP_QSTR_Foo``"
" syntax (e.g. they contain non-alphanumeric characters) are explicitly "
"provided in ``qstrdefs.h`` and ``qstrdefsport.h`` via the "
"``$(QSTR_DEFS)`` variable."
msgstr ""

#: ../../develop/qstr.rst:50
msgid "Processing happens in the following stages:"
msgstr ""

#: ../../develop/qstr.rst:52
msgid ""
"``qstr.i.last`` is the concatenation of putting every single input file "
"through the C pre-processor.  This means that any conditionally disabled "
"code will be removed, and macros expanded.  This means we don't add "
"strings to the pool that won't be used in the final firmware.  Because at"
" this stage (thanks to the ``NO_QSTR`` macro added by "
"``QSTR_GEN_CFLAGS``) there is no definition for ``MP_QSTR_Foo`` it passes"
" through this stage unaffected.  This file also includes comments from "
"the preprocessor that include line number information.  Note that this "
"step only uses files that have changed, which means that ``qstr.i.last`` "
"will only contain data from files that have changed since the last "
"compile."
msgstr ""

#: ../../develop/qstr.rst:63
msgid ""
"``qstr.split`` is an empty file created after running ``makeqstrdefs.py "
"split`` on qstr.i.last. It's just used as a dependency to indicate that "
"the step ran. This script outputs one file per input C file,  "
"``genhdr/qstr/...file.c.qstr``, which contains only the matched QSTRs. "
"Each QSTR is printed as ``Q(Foo)``. This step is necessary to combine the"
" existing files with the new data generated from the incremental update "
"in ``qstr.i.last``."
msgstr ""

#: ../../develop/qstr.rst:70
msgid ""
"``qstrdefs.collected.h`` is the output of concatenating ``genhdr/qstr/*``"
" using ``makeqstrdefs.py cat``.  This is now the full set of "
"``MP_QSTR_Foo``'s found in the code, now formatted as ``Q(Foo)``, one-"
"per-line, with duplicates. This file is only updated if the set of qstrs "
"has changed.  A hash of the QSTR data is written to another file "
"(``qstrdefs.collected.h.hash``) which allows it to track changes across "
"builds."
msgstr ""

#: ../../develop/qstr.rst:77
msgid ""
"Generate an enumeration, each entry of which maps a ``MP_QSTR_Foo`` to "
"it's corresponding index. It concatenates ``qstrdefs.collected.h`` with "
"``qstrdefs*.h``, then it transforms each line from ``Q(Foo)`` to "
"``\"Q(Foo)\"`` so they pass through the preprocessor unchanged.  Then the"
" preprocessor is used to deal with any conditional compilation in "
"``qstrdefs*.h``.  Then the transformation is undone back to ``Q(Foo)``, "
"and saved as ``qstrdefs.preprocessed.h``."
msgstr ""

#: ../../develop/qstr.rst:84
msgid ""
"``qstrdefs.generated.h`` is the output of ``makeqstrdata.py``.  For each "
"``Q(Foo)`` in qstrdefs.preprocessed.h (plus some extra hard-coded ones), "
"it outputs ``QDEF(MP_QSTR_Foo, (const byte*)\"hash\" \"Foo\")``."
msgstr ""

#: ../../develop/qstr.rst:88
msgid "Then in the main compile, two things happen with ``qstrdefs.generated.h``:"
msgstr ""

#: ../../develop/qstr.rst:90
msgid ""
"In qstr.h, each QDEF becomes an entry in an enum, which makes "
"``MP_QSTR_Foo`` available to code and equal to the index of that string "
"in the QSTR table."
msgstr ""

#: ../../develop/qstr.rst:93
msgid ""
"In qstr.c, the actual QSTR data table is generated as elements of the "
"``mp_qstr_const_pool->qstrs``."
msgstr ""

#: ../../develop/qstr.rst:99
msgid "Run-time QSTR generation"
msgstr ""

#: ../../develop/qstr.rst:101
msgid ""
"Additional QSTR pools can be created at runtime so that strings can be "
"added to them. For example, the code::"
msgstr ""

#: ../../develop/qstr.rst:106
msgid ""
"Will need to create a QSTR for the value of ``x`` so it can be used by "
"the \"load attr\" bytecode."
msgstr ""

#: ../../develop/qstr.rst:109
msgid ""
"Also, when compiling Python code, identifiers and literals need to have "
"QSTRs created.  Note: only literals shorter than 10 characters become "
"QSTRs.  This is because a regular string on the heap always takes up a "
"minimum of 16 bytes (one GC block), whereas QSTRs allow them to be packed"
" more efficiently into the pool."
msgstr ""

#: ../../develop/qstr.rst:114
msgid ""
"QSTR pools (and the underlying \"chunks\" that store the string data) are"
" allocated on-demand on the heap with a minimum size."
msgstr ""

