# SOME DESCRIPTIVE TITLE.
# Copyright (C) - The MicroPython Documentation is Copyright © 2014-2022,
# Damien P. George, Paul Sokolovsky, and contributors
# This file is distributed under the same license as the MicroPython
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: MicroPython 1.18\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-10 14:42+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../develop/qstr.rst:4
msgid "MicroPython string interning"
msgstr "MicroPython 字符串驻留"

#: ../../develop/qstr.rst:6
msgid ""
"MicroPython uses `string interning`_ to save both RAM and ROM.  This "
"avoids having to store duplicate copies of the same string.  Primarily, "
"this applies to identifiers in your code, as something like a function or"
" variable name is very likely to appear in multiple places in the code.  "
"In MicroPython an interned string is called a QSTR (uniQue STRing)."
msgstr ""
"MicroPython 使用 `string interning`_ （字符串驻留）来节省 RAM 和 ROM 。"
"这样可以避免了对于相同的字符串，存储了重复的引用。"
"主要是因为在你的代码中，某些标识符，比如函数或变量名，很可能会出现在多个地方。"
"在 MicroPython 中，一个驻留的字符串被称为 QSTR （uniQue STRing 的缩写，指唯一字符串）。"

#: ../../develop/qstr.rst:12
msgid ""
"A QSTR value (with type ``qstr``) is a index into a linked list of QSTR "
"pools. QSTRs store their length and a hash of their contents for fast "
"comparison during the de-duplication process.  All bytecode operations "
"that work with strings use a QSTR argument."
msgstr ""
"QSTR 值（以 ``qstr`` 类型存在）是一个链表中的 QSTR 值的索引。"
"QSTR 存储了其长度和内容的哈希值，以便快速的比较。"
"所有与字符串操作相关的 bytecode 操作都使用 QSTR 参数。"

#: ../../develop/qstr.rst:18
msgid "Compile-time QSTR generation"
msgstr "编译时进行的 QSTR 生成"

#: ../../develop/qstr.rst:20
msgid ""
"In the MicroPython C code, any strings that should be interned in the "
"final firmware are written as ``MP_QSTR_Foo``.  At compile time this will"
" evaluate to a ``qstr`` value that points to the index of ``\"Foo\"`` in "
"the QSTR pool."
msgstr ""
"在 MicroPython C 代码中，任何需要在最终的固件中驻留的字符串，都会写入为 ``MP_QSTR_Foo`` 。"
"在编译时，这将会将其转换为一个 ``qstr`` 值，指向 ``\"Foo\"`` 在 QSTR 池中的索引。"

#: ../../develop/qstr.rst:24
msgid ""
"A multi-step process in the ``Makefile`` makes this work.  In summary "
"this process has three parts:"
msgstr ""
"这项工作，是通过在 ``Makefile`` 中定义的多步操作来完成的。"
"总结来说，这个过程有三个部分："

#: ../../develop/qstr.rst:27
msgid "Find all ``MP_QSTR_Foo`` tokens in the code."
msgstr "在代码中找到所有的 ``MP_QSTR_Foo`` 标志。"

#: ../../develop/qstr.rst:29
msgid ""
"Generate a static QSTR pool containing all the string data (including "
"lengths and hashes)."
msgstr ""
"生成一个包含所有字符串数据（包含长度和哈希值）的静态 QSTR 池。"

#: ../../develop/qstr.rst:32
msgid ""
"Replace all ``MP_QSTR_Foo`` (via the preprocessor) with their "
"corresponding index."
msgstr ""
"将所有的 ``MP_QSTR_Foo`` （通过预处理器）替换为他们的对应的索引。"

#: ../../develop/qstr.rst:35
msgid "``MP_QSTR_Foo`` tokens are searched for in two sources:"
msgstr "搜索 ``MP_QSTR_Foo`` 标志的操作，会在以下两个来源中进行："

#: ../../develop/qstr.rst:37
msgid ""
"All files referenced in ``$(SRC_QSTR)``.  This is all C code (i.e. "
"``py``, ``extmod``, ``ports/stm32``) but not including third-party code "
"such as ``lib``."
msgstr ""
"所有在 ``$(SRC_QSTR)`` 中引用的文件。"
"这是所有 C 代码（即 ``py``、``extmod``、``ports/stm32``），但不包括第三方代码，"
"比如 ``lib`` 。"

#: ../../develop/qstr.rst:41
msgid ""
"Additional ``$(QSTR_GLOBAL_DEPENDENCIES)`` (which includes "
"``mpconfig*.h``)."
msgstr ""
"额外的 ``$(QSTR_GLOBAL_DEPENDENCIES)`` （包括 ``mpconfig*.h`` ）。"

#: ../../develop/qstr.rst:43
msgid ""
"*Note:* ``frozen_mpy.c`` (generated by mpy-tool.py) has its own QSTR "
"generation and pool."
msgstr ""
"*注意：* ``frozen_mpy.c`` （由 mpy-tool.py 生成）有自己的 QSTR 生成和池。"

#: ../../develop/qstr.rst:46
msgid ""
"Some additional strings that can't be expressed using the ``MP_QSTR_Foo``"
" syntax (e.g. they contain non-alphanumeric characters) are explicitly "
"provided in ``qstrdefs.h`` and ``qstrdefsport.h`` via the "
"``$(QSTR_DEFS)`` variable."
msgstr ""
"一些不能用 ``MP_QSTR_Foo`` 语法表达的字符串，比如它们包含非字母数字字符，"
"则需要在 ``qstrdefs.h`` 和 ``qstrdefsport.h`` 中通过 ``$(QSTR_DEFS)`` 变量进行指定。"

#: ../../develop/qstr.rst:50
msgid "Processing happens in the following stages:"
msgstr "处理过程会在以下阶段进行："

#: ../../develop/qstr.rst:52
msgid ""
"``qstr.i.last`` is the concatenation of putting every single input file "
"through the C pre-processor.  This means that any conditionally disabled "
"code will be removed, and macros expanded.  This means we don't add "
"strings to the pool that won't be used in the final firmware.  Because at"
" this stage (thanks to the ``NO_QSTR`` macro added by "
"``QSTR_GEN_CFLAGS``) there is no definition for ``MP_QSTR_Foo`` it passes"
" through this stage unaffected.  This file also includes comments from "
"the preprocessor that include line number information.  Note that this "
"step only uses files that have changed, which means that ``qstr.i.last`` "
"will only contain data from files that have changed since the last "
"compile."
msgstr ""
"``qstr.i.last`` 是将所有输入文件通过 C 预处理器进行合并的结果。"
"因此，任何不满足条件的代码都会被删除，并且宏会被替换。"
"这意味着我们未添加到池中的字符串，它们在最终的固件中无法被使用。"
"因为在这一阶段（得益于 ``QSTR_GEN_CFLAGS`` 添加的 ``NO_QSTR`` 宏），"
" ``MP_QSTR_Foo`` 尚未被定义，所以它会在这一阶段不受影响。"
"这个文件还包含了预处理器中的注释，其中包含行号信息。"
"注意，这一步只使用了文件已经改变的数据，这意味着 ``qstr.i.last`` 将只包含"
"从上次编译后改变的文件中的数据。"

#: ../../develop/qstr.rst:63
msgid ""
"``qstr.split`` is an empty file created after running ``makeqstrdefs.py "
"split`` on qstr.i.last. It's just used as a dependency to indicate that "
"the step ran. This script outputs one file per input C file,  "
"``genhdr/qstr/...file.c.qstr``, which contains only the matched QSTRs. "
"Each QSTR is printed as ``Q(Foo)``. This step is necessary to combine the"
" existing files with the new data generated from the incremental update "
"in ``qstr.i.last``."
msgstr ""
"``qstr.split`` 是在运行 ``makeqstrdefs.py split`` 后创建的空文件。"
"它只是用来作为依赖，表示这一阶段已经运行。"
"这个脚本会输出一个文件，每个输入 C 文件对应一个文件，"
"``genhdr/qstr/...file.c.qstr`` ，其中包含只包含匹配的 QSTR 的数据。"
"每个 QSTR 将被输出为 ``Q(Foo)`` 。"
"这一步是将现有的文件与新生成的数据从 ``qstr.i.last`` 中进行增量更新合并的必要步骤。"

#: ../../develop/qstr.rst:70
msgid ""
"``qstrdefs.collected.h`` is the output of concatenating ``genhdr/qstr/*``"
" using ``makeqstrdefs.py cat``.  This is now the full set of "
"``MP_QSTR_Foo``'s found in the code, now formatted as ``Q(Foo)``, one-"
"per-line, with duplicates. This file is only updated if the set of qstrs "
"has changed.  A hash of the QSTR data is written to another file "
"(``qstrdefs.collected.h.hash``) which allows it to track changes across "
"builds."
msgstr ""
"``qstrdefs.collected.h`` 是通过使用 ``makeqstrdefs.py cat`` 合并的 ``genhdr/qstr/*`` 的输出。"
"这是现在所有在代码中找到的 ``MP_QSTR_Foo`` 的集合，且在这一步格式化为 ``Q(Foo)`` ，"
"每行一个，并且有重复。这个文件只有在 QSTR 的集合发生改变时才会更新。"
"QSTR 数据的哈希值已经写入另一个文件（``qstrdefs.collected.h.hash``），"
"用于支撑它跟踪构建之间的更改。"

#: ../../develop/qstr.rst:77
msgid ""
"Generate an enumeration, each entry of which maps a ``MP_QSTR_Foo`` to "
"it's corresponding index. It concatenates ``qstrdefs.collected.h`` with "
"``qstrdefs*.h``, then it transforms each line from ``Q(Foo)`` to "
"``\"Q(Foo)\"`` so they pass through the preprocessor unchanged.  Then the"
" preprocessor is used to deal with any conditional compilation in "
"``qstrdefs*.h``.  Then the transformation is undone back to ``Q(Foo)``, "
"and saved as ``qstrdefs.preprocessed.h``."
msgstr ""
"生成一个枚举，每个条目都映射一个 ``MP_QSTR_Foo`` 到它的对应的索引。"
"它将 ``qstrdefs.collected.h`` 与 ``qstrdefs*.h`` 合并，然后将每行从 ``Q(Foo)`` "
"转换为 ``\"Q(Foo)\"`` ，这样它们就不会受到前置编译器的影响。"
"接着，前置编译器会处理 ``qstrdefs*.h`` 中的任何带条件判断的编译。"
"然后，将其转换回 ``Q(Foo)`` ，并保存为 ``qstrdefs.preprocessed.h`` 。"

#: ../../develop/qstr.rst:84
msgid ""
"``qstrdefs.generated.h`` is the output of ``makeqstrdata.py``.  For each "
"``Q(Foo)`` in qstrdefs.preprocessed.h (plus some extra hard-coded ones), "
"it outputs ``QDEF(MP_QSTR_Foo, (const byte*)\"hash\" \"Foo\")``."
msgstr ""
"``qstrdefs.generated.h`` 是 ``makeqstrdata.py`` 的输出。"
"对于 qstrdefs.preprocessed.h 中的每个 ``Q(Foo)`` （加上一些额外的硬编码的），"
"它都会输出 ``QDEF(MP_QSTR_Foo, (const byte*)\"hash\" \"Foo\")`` 。"

#: ../../develop/qstr.rst:88
msgid "Then in the main compile, two things happen with ``qstrdefs.generated.h``:"
msgstr "然后，在主编译中，与 ``qstrdefs.generated.h`` 相关的两件事情发生了："

#: ../../develop/qstr.rst:90
msgid ""
"In qstr.h, each QDEF becomes an entry in an enum, which makes "
"``MP_QSTR_Foo`` available to code and equal to the index of that string "
"in the QSTR table."
msgstr ""
"在 qstr.h 中，每个 QDEF 就会变成一个枚举的条目，这样就使得 ``MP_QSTR_Foo`` 可用，"
"并且等同于 QSTR 表中该字符串的索引。"

#: ../../develop/qstr.rst:93
msgid ""
"In qstr.c, the actual QSTR data table is generated as elements of the "
"``mp_qstr_const_pool->qstrs``."
msgstr ""
"在 qstr.c 中，实际的 QSTR 数据表就会被生成为 ``mp_qstr_const_pool->qstrs`` 的元素。"

#: ../../develop/qstr.rst:99
msgid "Run-time QSTR generation"
msgstr "运行时进行的 QSTR 生成"

#: ../../develop/qstr.rst:101
msgid ""
"Additional QSTR pools can be created at runtime so that strings can be "
"added to them. For example, the code::"
msgstr ""
"可以在运行时创建额外的 QSTR 池，以便将字符串添加到其中。"
"例如，下述代码："

#: ../../develop/qstr.rst:106
msgid ""
"Will need to create a QSTR for the value of ``x`` so it can be used by "
"the \"load attr\" bytecode."
msgstr ""
"需要为 ``x`` 的值创建一个 QSTR，以便它能被 \"load attr\" 字节码所用。"

#: ../../develop/qstr.rst:109
msgid ""
"Also, when compiling Python code, identifiers and literals need to have "
"QSTRs created.  Note: only literals shorter than 10 characters become "
"QSTRs.  This is because a regular string on the heap always takes up a "
"minimum of 16 bytes (one GC block), whereas QSTRs allow them to be packed"
" more efficiently into the pool."
msgstr ""
"同时，当编译 Python 代码时，标识符和字面量需要使用创建好的 QSTR。"
"注意：只有字面量长度小于 10 个字符的字符串才会被转换成 QSTR。"
"这是因为一个普通的字符串在堆上总是最少占用 16 字节（一个 GC 块），而 QSTR 则使它们被更有效地放入池中。"

#: ../../develop/qstr.rst:114
msgid ""
"QSTR pools (and the underlying \"chunks\" that store the string data) are"
" allocated on-demand on the heap with a minimum size."
msgstr ""
"QSTR 池（和存储字符串数据的基本块 \"chunks\" ）是在堆上使用最小尺寸按需分配的。"

