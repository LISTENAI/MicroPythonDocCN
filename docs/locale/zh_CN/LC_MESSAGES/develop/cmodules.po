# SOME DESCRIPTIVE TITLE.
# Copyright (C) - The MicroPython Documentation is Copyright Â© 2014-2022,
# Damien P. George, Paul Sokolovsky, and contributors
# This file is distributed under the same license as the MicroPython
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: MicroPython 1.18\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-10 14:42+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../develop/cmodules.rst:4
msgid "MicroPython external C modules"
msgstr ""

#: ../../develop/cmodules.rst:6
msgid ""
"When developing modules for use with MicroPython you may find you run "
"into limitations with the Python environment, often due to an inability "
"to access certain hardware resources or Python speed limitations."
msgstr ""

#: ../../develop/cmodules.rst:10
msgid ""
"If your limitations can't be resolved with suggestions in "
":ref:`speed_python`, writing some or all of your module in C (and/or C++ "
"if implemented for your port) is a viable option."
msgstr ""

#: ../../develop/cmodules.rst:14
msgid ""
"If your module is designed to access or work with commonly available "
"hardware or libraries please consider implementing it inside the "
"MicroPython source tree alongside similar modules and submitting it as a "
"pull request. If however you're targeting obscure or proprietary systems "
"it may make more sense to keep this external to the main MicroPython "
"repository."
msgstr ""

#: ../../develop/cmodules.rst:20
msgid ""
"This chapter describes how to compile such external modules into the "
"MicroPython executable or firmware image.  Both Make and CMake build "
"tools are supported, and when writing an external module it's a good idea"
" to add the build files for both of these tools so the module can be used"
" on all ports.  But when compiling a particular port you will only need "
"to use one method of building, either Make or CMake."
msgstr ""

#: ../../develop/cmodules.rst:27
msgid ""
"An alternative approach is to use :ref:`natmod` which allows writing "
"custom C code that is placed in a .mpy file, which can be imported "
"dynamically in to a running MicroPython system without the need to "
"recompile the main firmware."
msgstr ""

#: ../../develop/cmodules.rst:33
msgid "Structure of an external C module"
msgstr ""

#: ../../develop/cmodules.rst:35
msgid "A MicroPython user C module is a directory with the following files:"
msgstr ""

#: ../../develop/cmodules.rst:37
msgid "``*.c`` / ``*.cpp`` / ``*.h`` source code files for your module."
msgstr ""

#: ../../develop/cmodules.rst:39
msgid ""
"These will typically include the low level functionality being "
"implemented and the MicroPython binding functions to expose the functions"
" and module(s)."
msgstr ""

#: ../../develop/cmodules.rst:42
msgid ""
"Currently the best reference for writing these functions/modules is to "
"find similar modules within the MicroPython tree and use them as "
"examples."
msgstr ""

#: ../../develop/cmodules.rst:45
msgid "``micropython.mk`` contains the Makefile fragment for this module."
msgstr ""

#: ../../develop/cmodules.rst:47
msgid ""
"``$(USERMOD_DIR)`` is available in ``micropython.mk`` as the path to your"
" module directory. As it's redefined for each c module, is should be "
"expanded in your ``micropython.mk`` to a local make variable, eg "
"``EXAMPLE_MOD_DIR := $(USERMOD_DIR)``"
msgstr ""

#: ../../develop/cmodules.rst:52
msgid ""
"Your ``micropython.mk`` must add your modules source files relative to "
"your expanded copy of ``$(USERMOD_DIR)`` to ``SRC_USERMOD``, eg "
"``SRC_USERMOD += $(EXAMPLE_MOD_DIR)/example.c``"
msgstr ""

#: ../../develop/cmodules.rst:56
msgid ""
"If you have custom compiler options (like ``-I`` to add directories to "
"search for header files), these should be added to ``CFLAGS_USERMOD`` for"
" C code and to ``CXXFLAGS_USERMOD`` for C++ code."
msgstr ""

#: ../../develop/cmodules.rst:60
msgid "``micropython.cmake`` contains the CMake configuration for this module."
msgstr ""

#: ../../develop/cmodules.rst:62
msgid ""
"In ``micropython.cmake``, you may use ``${CMAKE_CURRENT_LIST_DIR}`` as "
"the path to the current module."
msgstr ""

#: ../../develop/cmodules.rst:65
msgid ""
"Your ``micropython.cmake`` should define an ``INTERFACE`` library and "
"associate your source files, compile definitions and include directories "
"with it. The library should then be linked to the ``usermod`` target."
msgstr ""

#: ../../develop/cmodules.rst:84
msgid "See below for full usage example."
msgstr ""

#: ../../develop/cmodules.rst:88
msgid "Basic example"
msgstr ""

#: ../../develop/cmodules.rst:90
msgid ""
"This simple module named ``cexample`` provides a single function "
"``cexample.add_ints(a, b)`` which adds the two integer args together and "
"returns the result. It can be found in the MicroPython source tree `in "
"the examples directory "
"<https://github.com/micropython/micropython/tree/master/examples/usercmodule/cexample>`_"
" and has a source file and a Makefile fragment with content as described "
"above::"
msgstr ""

#: ../../develop/cmodules.rst:105
msgid ""
"Refer to the comments in these files for additional explanation. Next to "
"the ``cexample`` module there's also ``cppexample`` which works in the "
"same way but shows one way of mixing C and C++ code in MicroPython."
msgstr ""

#: ../../develop/cmodules.rst:112
msgid "Compiling the cmodule into MicroPython"
msgstr ""

#: ../../develop/cmodules.rst:114
msgid ""
"To build such a module, compile MicroPython (see `getting started "
"<https://github.com/micropython/micropython/wiki/Getting-Started>`_), "
"applying 2 modifications:"
msgstr ""

#: ../../develop/cmodules.rst:118
msgid ""
"Set the build-time flag ``USER_C_MODULES`` to point to the modules you "
"want to include.  For ports that use Make this variable should be a "
"directory which is searched automatically for modules.  For ports that "
"use CMake this variable should be a file which includes the modules to "
"build.  See below for details."
msgstr ""

#: ../../develop/cmodules.rst:124
msgid ""
"Enable the modules by setting the corresponding C preprocessor macro to "
"1.  This is only needed if the modules you are building are not "
"automatically enabled."
msgstr ""

#: ../../develop/cmodules.rst:128
msgid ""
"For building the example modules which come with MicroPython, set "
"``USER_C_MODULES`` to the ``examples/usercmodule`` directory for Make, or"
" to ``examples/usercmodule/micropython.cmake`` for CMake."
msgstr ""

#: ../../develop/cmodules.rst:132
msgid ""
"For example, here's how the to build the unix port with the example "
"modules:"
msgstr ""

#: ../../develop/cmodules.rst:139
msgid ""
"You may need to run ``make clean`` once at the start when including new "
"user modules in the build.  The build output will show the modules "
"found::"
msgstr ""

#: ../../develop/cmodules.rst:147
msgid ""
"For a CMake-based port such as rp2, this will look a little different "
"(note that CMake is actually invoked by ``make``):"
msgstr ""

#: ../../develop/cmodules.rst:155
msgid ""
"Again, you may need to run ``make clean`` first for CMake to pick up the "
"user modules.  The CMake build output lists the modules by name::"
msgstr ""

#: ../../develop/cmodules.rst:163
msgid ""
"The contents of the top-level ``micropython.cmake`` can be used to "
"control which modules are enabled."
msgstr ""

#: ../../develop/cmodules.rst:166
msgid ""
"For your own projects it's more convenient to keep custom code out of the"
" main MicroPython source tree, so a typical project directory structure "
"will look like this::"
msgstr ""

#: ../../develop/cmodules.rst:186
msgid ""
"When building with Make set ``USER_C_MODULES`` to the "
"``my_project/modules`` directory.  For example, building the stm32 port:"
msgstr ""

#: ../../develop/cmodules.rst:194
msgid ""
"When building with CMake the top level ``micropython.cmake`` -- found "
"directly in the ``my_project/modules`` directory -- should ``include`` "
"all of the modules you want to have available:"
msgstr ""

#: ../../develop/cmodules.rst:203
msgid "Then build with:"
msgstr ""

#: ../../develop/cmodules.rst:210
msgid ""
"Note that the esp32 port needs the extra ``..`` for relative paths due to"
" the location of its main ``CMakeLists.txt`` file.   You can also specify"
" absolute paths to ``USER_C_MODULES``."
msgstr ""

#: ../../develop/cmodules.rst:214
msgid ""
"All modules specified by the ``USER_C_MODULES`` variable (either found in"
" this directory when using Make, or added via ``include`` when using "
"CMake) will be compiled, but only those which are enabled will be "
"available for importing. User modules are usually enabled by default "
"(this is decided by the developer of the module), in which case there is "
"nothing more to do than set ``USER_C_MODULES`` as described above."
msgstr ""

#: ../../develop/cmodules.rst:221
msgid ""
"If a module is not enabled by default then the corresponding C "
"preprocessor macro must be enabled.  This macro name can be found by "
"searching for the ``MP_REGISTER_MODULE`` line in the module's source code"
" (it usually appears at the end of the main source file). The third "
"argument to ``MP_REGISTER_MODULE`` is the macro name, and this must be "
"set to 1 using ``CFLAGS_EXTRA`` to make the module available.  If the "
"third argument is just the number 1 then the module is enabled by "
"default."
msgstr ""

#: ../../develop/cmodules.rst:228
msgid ""
"For example, the ``examples/usercmodule/cexample`` module is enabled by "
"default so has the following line in its source code:"
msgstr ""

#: ../../develop/cmodules.rst:235
msgid ""
"Alternatively, to make this module disabled by default but selectable "
"through a preprocessor configuration option, it would be:"
msgstr ""

#: ../../develop/cmodules.rst:242
msgid ""
"In this case the module is enabled by adding "
"``CFLAGS_EXTRA=-DMODULE_CEXAMPLE_ENABLED=1`` to the ``make`` command, or "
"editing ``mpconfigport.h`` or ``mpconfigboard.h`` to add"
msgstr ""

#: ../../develop/cmodules.rst:249
msgid ""
"Note that the exact method depends on the port as they have different "
"structures.  If not done correctly it will compile but importing will "
"fail to find the module."
msgstr ""

#: ../../develop/cmodules.rst:255
msgid "Module usage in MicroPython"
msgstr ""

#: ../../develop/cmodules.rst:257
msgid ""
"Once built into your copy of MicroPython, the module can now be accessed "
"in Python just like any other builtin module, e.g."
msgstr ""

