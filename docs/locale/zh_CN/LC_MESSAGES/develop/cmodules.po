# SOME DESCRIPTIVE TITLE.
# Copyright (C) - The MicroPython Documentation is Copyright © 2014-2022,
# Damien P. George, Paul Sokolovsky, and contributors
# This file is distributed under the same license as the MicroPython
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: MicroPython 1.18\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-10 14:42+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../develop/cmodules.rst:4
msgid "MicroPython external C modules"
msgstr "MicroPython 外部 C 模块"

#: ../../develop/cmodules.rst:6
msgid ""
"When developing modules for use with MicroPython you may find you run "
"into limitations with the Python environment, often due to an inability "
"to access certain hardware resources or Python speed limitations."
msgstr ""
"当开发 MicroPython 的模块时，你会发现可能会遇到一些 Python 环境的限制，"
"这通常是由于无法访问某些硬件资源或 Python 速度限制。"

#: ../../develop/cmodules.rst:10
msgid ""
"If your limitations can't be resolved with suggestions in "
":ref:`speed_python`, writing some or all of your module in C (and/or C++ "
"if implemented for your port) is a viable option."
msgstr ""
"如果你的限制无法通过使用 :ref:`speed_python` 中的建议解决的话，"
"可以尝试使用 C (如果你的适配端支持的话甚至可以是 C++ ) 编写你的模块。"

#: ../../develop/cmodules.rst:14
msgid ""
"If your module is designed to access or work with commonly available "
"hardware or libraries please consider implementing it inside the "
"MicroPython source tree alongside similar modules and submitting it as a "
"pull request. If however you're targeting obscure or proprietary systems "
"it may make more sense to keep this external to the main MicroPython "
"repository."
msgstr ""
"如果你的模块是旨在访问或与常用的硬件或库协作，请考虑在 MicroPython "
"源码树中内嵌一些相似的模块，并提交 pull request 。"
"如果你的目标是模糊的或专有的系统，则可能更适合将这个模块保持在 "
"主 MicroPython 仓库之外。"

#: ../../develop/cmodules.rst:20
msgid ""
"This chapter describes how to compile such external modules into the "
"MicroPython executable or firmware image.  Both Make and CMake build "
"tools are supported, and when writing an external module it's a good idea"
" to add the build files for both of these tools so the module can be used"
" on all ports.  But when compiling a particular port you will only need "
"to use one method of building, either Make or CMake."
msgstr ""
"这一章节描述了如何将这样的外部模块编译到 MicroPython 可执行文件或固件镜像。"
"不论 Make 和 CMake 的编译工具都是支持的，并且当写一个外部模块时，建议同时为这两个工具添加"
"的编译配置文件，以便于让这个模块就可在所有的适配端上使用。"
"但是，当只为一个特定的适配端构建时，你可能只需要使用一种方法来编译，可以是 Make 或 CMake。"

#: ../../develop/cmodules.rst:27
msgid ""
"An alternative approach is to use :ref:`natmod` which allows writing "
"custom C code that is placed in a .mpy file, which can be imported "
"dynamically in to a running MicroPython system without the need to "
"recompile the main firmware."
msgstr ""
"另一种方法是使用 :ref:`natmod` ，这一方式允许编写自定义的、被放置在 .mpy 文件中的 C 代码，"
"这些代码可以在运行的 MicroPython 系统中动态导入，"
"而不需要重新编译主固件。"

#: ../../develop/cmodules.rst:33
msgid "Structure of an external C module"
msgstr "外部 C 模块的结构"

#: ../../develop/cmodules.rst:35
msgid "A MicroPython user C module is a directory with the following files:"
msgstr "一个 MicroPython 用户 C 模块是一个具有以下文件的目录："

#: ../../develop/cmodules.rst:37
msgid "``*.c`` / ``*.cpp`` / ``*.h`` source code files for your module."
msgstr "你的模块的 ``*.c`` / ``*.cpp`` / ``*.h`` 源代码文件。"

#: ../../develop/cmodules.rst:39
msgid ""
"These will typically include the low level functionality being "
"implemented and the MicroPython binding functions to expose the functions"
" and module(s)."
msgstr ""
"这些文件通常包括实现的底层功能和提供给 MicroPython 的、用于暴露这些函数和模块的绑定函数。"

#: ../../develop/cmodules.rst:42
msgid ""
"Currently the best reference for writing these functions/modules is to "
"find similar modules within the MicroPython tree and use them as "
"examples."
msgstr ""
"目前编写这些函数/模块的最佳参考是，在 MicroPython 树中找到相似的模块作为示例。"

#: ../../develop/cmodules.rst:45
msgid "``micropython.mk`` contains the Makefile fragment for this module."
msgstr "``micropython.mk`` 包含了这个模块的 Makefile 片段。"

#: ../../develop/cmodules.rst:47
msgid ""
"``$(USERMOD_DIR)`` is available in ``micropython.mk`` as the path to your"
" module directory. As it's redefined for each c module, is should be "
"expanded in your ``micropython.mk`` to a local make variable, eg "
"``EXAMPLE_MOD_DIR := $(USERMOD_DIR)``"
msgstr ""
"``$(USERMOD_DIR)`` 在 ``micropython.mk`` 中作为模块目录路径的变量。"
"它在每个 c 模块中都会重新定义，因此在你的 ``micropython.mk`` 中应该"
"将它赋值为一个本地 make 变量，例如 ``EXAMPLE_MOD_DIR := $(USERMOD_DIR)``"

#: ../../develop/cmodules.rst:52
msgid ""
"Your ``micropython.mk`` must add your modules source files relative to "
"your expanded copy of ``$(USERMOD_DIR)`` to ``SRC_USERMOD``, eg "
"``SRC_USERMOD += $(EXAMPLE_MOD_DIR)/example.c``"
msgstr ""
"你的 ``micropython.mk`` 必须在 ``SRC_USERMOD` `中，添加你的模块源代码，"
"其路径应当是你赋值的对应 ``SRC_USERMOD`` 的变量的相对路径，例如 "
"``SRC_USERMOD += $(EXAMPLE_MOD_DIR)/example.c``"

#: ../../develop/cmodules.rst:56
msgid ""
"If you have custom compiler options (like ``-I`` to add directories to "
"search for header files), these should be added to ``CFLAGS_USERMOD`` for"
" C code and to ``CXXFLAGS_USERMOD`` for C++ code."
msgstr ""
"如果你有自定义的编译选项（例如 ``-I`` 来添加头文件所在的目录），"
"则这些选项，为了在 C 代码可用，添加到 ``CFLAGS_USERMOD`` 中；"
"为了在 C++ 代码可用，配置到 ``CXXFLAGS_USERMOD`` 中。"

#: ../../develop/cmodules.rst:60
msgid "``micropython.cmake`` contains the CMake configuration for this module."
msgstr "``micropython.cmake`` 包含了这个模块的 CMake 配置。"

#: ../../develop/cmodules.rst:62
msgid ""
"In ``micropython.cmake``, you may use ``${CMAKE_CURRENT_LIST_DIR}`` as "
"the path to the current module."
msgstr ""
"在 ``micropython.cmake`` 中，你可以使用 ``${CMAKE_CURRENT_LIST_DIR}`` "
"作为当前模块的路径。"

#: ../../develop/cmodules.rst:65
msgid ""
"Your ``micropython.cmake`` should define an ``INTERFACE`` library and "
"associate your source files, compile definitions and include directories "
"with it. The library should then be linked to the ``usermod`` target."
msgstr ""
"你的 ``micropython.cmake`` 应该定义一个 ``INTERFACE`` 库，并将你的源代码、"
"编译定义和头文件目录与它关联。这个库应该被链接到 ``usermod`` 目标。"

#: ../../develop/cmodules.rst:84
msgid "See below for full usage example."
msgstr "在下文参考完整示例。"

#: ../../develop/cmodules.rst:88
msgid "Basic example"
msgstr "基本示例"

#: ../../develop/cmodules.rst:90
msgid ""
"This simple module named ``cexample`` provides a single function "
"``cexample.add_ints(a, b)`` which adds the two integer args together and "
"returns the result. It can be found in the MicroPython source tree `in "
"the examples directory "
"<https://github.com/micropython/micropython/tree/master/examples/usercmodule/cexample>`_"
" and has a source file and a Makefile fragment with content as described "
"above::"
msgstr ""
"该简单的模块名为 ``cexample``，用于提供一个函数 ``cexample.add_ints(a, b)`` "
"，该函数把两个整数相加并返回结果。它可以在 MicroPython 源代码树中的"
" `examples 目录 "
"<https://github.com/micropython/micropython/tree/master/examples/usercmodule/cexample>`_"
" 中找到，其中包含一个源码文件和一个 Makefile 片段内容如上所述。"

#: ../../develop/cmodules.rst:105
msgid ""
"Refer to the comments in these files for additional explanation. Next to "
"the ``cexample`` module there's also ``cppexample`` which works in the "
"same way but shows one way of mixing C and C++ code in MicroPython."
msgstr ""
"参考这些文件的注释以获取额外的说明。紧接 ``cexample`` 模块的还有 "
"``cppexample`` 模块，该模块与 ``cexample`` 模块执行相同的行为，但展示了一种方式，"
"说明在 MicroPython 中如何使用 C 和 C++ 代码混合开发。"

#: ../../develop/cmodules.rst:112
msgid "Compiling the cmodule into MicroPython"
msgstr "将 c 模块编译到 MicroPython"

#: ../../develop/cmodules.rst:114
msgid ""
"To build such a module, compile MicroPython (see `getting started "
"<https://github.com/micropython/micropython/wiki/Getting-Started>`_), "
"applying 2 modifications:"
msgstr ""
"要构建这样的模块，编译 MicroPython (参考 `快速开始 "
"<https://github.com/micropython/micropython/wiki/Getting-Started>`_ )"
"，并执行 2 个修改："

#: ../../develop/cmodules.rst:118
msgid ""
"Set the build-time flag ``USER_C_MODULES`` to point to the modules you "
"want to include.  For ports that use Make this variable should be a "
"directory which is searched automatically for modules.  For ports that "
"use CMake this variable should be a file which includes the modules to "
"build.  See below for details."
msgstr ""
"将构建时标识 ``USER_C_MODULES`` 指向来你要包含的模块。 "
"如果使用 Make ，这个变量应该是一个指向自动搜索模块的目录。"
"如果使用 CMake ，这个变量应该是一个包含要构建的模块的文件。"
"详情见下文。"

#: ../../develop/cmodules.rst:124
msgid ""
"Enable the modules by setting the corresponding C preprocessor macro to "
"1.  This is only needed if the modules you are building are not "
"automatically enabled."
msgstr ""
"当且仅当你要构建的模块不被自动启用时，需要将对应的 C 预处理宏设置为 1。"

#: ../../develop/cmodules.rst:128
msgid ""
"For building the example modules which come with MicroPython, set "
"``USER_C_MODULES`` to the ``examples/usercmodule`` directory for Make, or"
" to ``examples/usercmodule/micropython.cmake`` for CMake."
msgstr ""
"为了构建和 MicroPython 关联的示例模块，使用 Make 时将 ``USER_C_MODULES`` 设置为 "
"``examples/usercmodule`` 目录，使用 CMake 时则是 "
"``examples/usercmodule/micropython.cmake``。"

#: ../../develop/cmodules.rst:132
msgid ""
"For example, here's how the to build the unix port with the example "
"modules:"
msgstr ""
"以下示例介绍了如何构建 unix 适配端，并使用示例模块的方法："

#: ../../develop/cmodules.rst:139
msgid ""
"You may need to run ``make clean`` once at the start when including new "
"user modules in the build.  The build output will show the modules "
"found::"
msgstr ""
"如果你要在构建时包含新的用户模块，你可能需要在构建开始时运行 ``make clean`` 。"
"构建时的输出会展示找到的模块："

#: ../../develop/cmodules.rst:147
msgid ""
"For a CMake-based port such as rp2, this will look a little different "
"(note that CMake is actually invoked by ``make``):"
msgstr ""
"如果是基于 CMake 构建的适配端，例如树莓派，这种方法会有些不同（请注意 CMake 最终是调用"
" ``make`` 来完成构建的）："

#: ../../develop/cmodules.rst:155
msgid ""
"Again, you may need to run ``make clean`` first for CMake to pick up the "
"user modules.  The CMake build output lists the modules by name::"
msgstr ""
"你需要先为 CMake 再运行一遍 ``make clean`` 来启用用户模块。"
" CMake 构建时的输出会按名称逐个列出模块："

#: ../../develop/cmodules.rst:163
msgid ""
"The contents of the top-level ``micropython.cmake`` can be used to "
"control which modules are enabled."
msgstr ""
"最上层的 ``micropython.cmake`` 文件的内容可以用来控制哪些模块要启用。"

#: ../../develop/cmodules.rst:166
msgid ""
"For your own projects it's more convenient to keep custom code out of the"
" main MicroPython source tree, so a typical project directory structure "
"will look like this::"
msgstr ""
"对于自己的项目，更方便的是将自定义代码移出 MicroPython 源代码树，"
"所以通常一个项目目录结构会如下："

#: ../../develop/cmodules.rst:186
msgid ""
"When building with Make set ``USER_C_MODULES`` to the "
"``my_project/modules`` directory.  For example, building the stm32 port:"
msgstr ""
"使用 Make 构建时，将 ``USER_C_MODULES`` 设为 ``my_project/modules`` 目录。"
"例如构建 stm32 适配端使用："

#: ../../develop/cmodules.rst:194
msgid ""
"When building with CMake the top level ``micropython.cmake`` -- found "
"directly in the ``my_project/modules`` directory -- should ``include`` "
"all of the modules you want to have available:"
msgstr ""
"使用 CMake 构建时，最上层的 ``micropython.cmake`` 文件（可在 "
"``my_project/modules`` 目录中找到）应该 ``include`` 所有要使用的模块："

#: ../../develop/cmodules.rst:203
msgid "Then build with:"
msgstr "然后这样构建："

#: ../../develop/cmodules.rst:210
msgid ""
"Note that the esp32 port needs the extra ``..`` for relative paths due to"
" the location of its main ``CMakeLists.txt`` file.   You can also specify"
" absolute paths to ``USER_C_MODULES``."
msgstr ""
"请注意， esp32 适配端需要额外的 ``..`` 来表示相对路径，因为它的主 "
"``CMakeLists.txt`` 文件在项目根目录中。你也可以用 ``USER_C_MODULES`` 指定到绝对路径。"

#: ../../develop/cmodules.rst:214
msgid ""
"All modules specified by the ``USER_C_MODULES`` variable (either found in"
" this directory when using Make, or added via ``include`` when using "
"CMake) will be compiled, but only those which are enabled will be "
"available for importing. User modules are usually enabled by default "
"(this is decided by the developer of the module), in which case there is "
"nothing more to do than set ``USER_C_MODULES`` as described above."
msgstr ""
"所有通过 ``USER_C_MODULES`` 变量指定的模块（使用 Make 时，在这个变量指定的目录中查找；"
"使用 CMake 时，则通过 ``include`` 添加）都会被编译，但只有启用的模块才会被 "
"使用。用户模块通常会被默认启用（这是由模块开发者决定的），所以如果你不 "
"想要某些模块，只需要将 ``USER_C_MODULES`` 变量设为空即可。"

#: ../../develop/cmodules.rst:221
msgid ""
"If a module is not enabled by default then the corresponding C "
"preprocessor macro must be enabled.  This macro name can be found by "
"searching for the ``MP_REGISTER_MODULE`` line in the module's source code"
" (it usually appears at the end of the main source file). The third "
"argument to ``MP_REGISTER_MODULE`` is the macro name, and this must be "
"set to 1 using ``CFLAGS_EXTRA`` to make the module available.  If the "
"third argument is just the number 1 then the module is enabled by "
"default."
msgstr ""
"如果模块不默认启用，则必须启用对应的 C 预处理器宏。这个宏名称可以在模块的源代码中搜索到（通常是模块的主源文件最后一行）。"
"``MP_REGISTER_MODULE`` 的第三个参数是宏名称，这个宏名称必须使用 ``CFLAGS_EXTRA`` 来设置为 1 ，以使模块可用。如果第三个参数是 1 ，则模块默认启用。"

#: ../../develop/cmodules.rst:228
msgid ""
"For example, the ``examples/usercmodule/cexample`` module is enabled by "
"default so has the following line in its source code:"
msgstr ""
"例如，``examples/usercmodule/cexample`` 模块默认启用，所以它的源代码中有如下一行："

#: ../../develop/cmodules.rst:235
msgid ""
"Alternatively, to make this module disabled by default but selectable "
"through a preprocessor configuration option, it would be:"
msgstr ""
"另外，如果想要使这个模块不默认启用，但通过预处理器配置选项来选择，则是："

#: ../../develop/cmodules.rst:242
msgid ""
"In this case the module is enabled by adding "
"``CFLAGS_EXTRA=-DMODULE_CEXAMPLE_ENABLED=1`` to the ``make`` command, or "
"editing ``mpconfigport.h`` or ``mpconfigboard.h`` to add"
msgstr ""
"这种情况下，若要启用模块，可通过在 ``make`` 命令添加 ``CFLAGS_EXTRA=-DMODULE_CEXAMPLE_ENABLED=1`` ，或者编辑 ``mpconfigport.h`` 或 ``mpconfigboard.h`` 添加以下行"

#: ../../develop/cmodules.rst:249
msgid ""
"Note that the exact method depends on the port as they have different "
"structures.  If not done correctly it will compile but importing will "
"fail to find the module."
msgstr ""
"请注意，这种方法取决于适配端，因为不同适配端有不同的结构。如果没有按照正确做法配置，也会加入编译，但导入将失败。"

#: ../../develop/cmodules.rst:255
msgid "Module usage in MicroPython"
msgstr "在 MicroPython 中使用模块"

#: ../../develop/cmodules.rst:257
msgid ""
"Once built into your copy of MicroPython, the module can now be accessed "
"in Python just like any other builtin module, e.g."
msgstr ""
"一旦编译到你的 MicroPython 固件中，模块就可以在 Python 中被直接访问，例如："

