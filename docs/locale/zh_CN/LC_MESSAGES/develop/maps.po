# SOME DESCRIPTIVE TITLE.
# Copyright (C) - The MicroPython Documentation is Copyright © 2014-2022,
# Damien P. George, Paul Sokolovsky, and contributors
# This file is distributed under the same license as the MicroPython
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: MicroPython 1.18\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-10 14:42+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../develop/maps.rst:4
msgid "Maps and Dictionaries"
msgstr "映射（Maps）与字典（Dictionaries）"

#: ../../develop/maps.rst:6
msgid ""
"MicroPython dictionaries and maps use techniques called open addressing "
"and linear probing. This chapter details both of these methods."
msgstr ""
"MicroPython 字典和映射使用的是被称为开放地址和线性探测的技术。这一章节将详细介绍这两种技术。"

#: ../../develop/maps.rst:10
msgid "Open addressing"
msgstr "开放寻址"

#: ../../develop/maps.rst:12
msgid ""
"`Open addressing <https://en.wikipedia.org/wiki/Open_addressing>`_ is "
"used to resolve collisions. Collisions are very common occurrences and "
"happen when two items happen to hash to the same slot or location. For "
"example, given a hash setup as this:"
msgstr ""
"`开放寻址 <https://en.wikipedia.org/wiki/Open_addressing>`_ 是用来解决冲突的一项技术。"
"冲突是非常常见的情况，发生在两个项目的哈希值相同时。例如，给定一个哈希设置如下："

#: ../../develop/maps.rst:18
msgid ""
"If there is a request to fill slot ``0`` with ``70``, since the slot "
"``0`` is not empty, open addressing finds the next available slot in the "
"dictionary to service this request. This sequential search for an "
"alternate location is called *probing*. There are several sequence "
"probing algorithms but MicroPython uses linear probing that is described "
"in the next section."
msgstr ""
"如果请求填充槽 ``0`` 的值为 ``70``，因为槽 ``0`` 不为空，开放寻址将找到下一个可用的槽来服务这个请求。"
"这种对替代位置的顺序搜索称为 *探测* 。存在数种用于顺序探测的算法，但 MicroPython 使用的是线性探测，这是在下一节中描述的。"

#: ../../develop/maps.rst:24
msgid "Linear probing"
msgstr "线性探测"

#: ../../develop/maps.rst:26
msgid ""
"Linear probing is one of the methods for finding an available address or "
"slot in a dictionary. In MicroPython, it is used with open addressing. To"
" service the request described above, unlike other probing algorithms, "
"linear probing assumes a fixed interval of ``1`` between probes. The "
"request will therefore be serviced by placing the item in the next free "
"slot which is slot ``4`` in our example:"
msgstr ""
"线性探测是在字典中找到可用地址或槽的一种方法。在 MicroPython 中，它被用于开放寻址。"
"为了服务上述描述的请求，线性探测假设每次探测的固定的间隔为 ``1`` 。"
"请求将被放置到下一个能满足需求的空闲槽中，在我们的例子中，即槽 ``4`` ："

#: ../../develop/maps.rst:33
msgid ""
"The same methods i.e open addressing and linear probing are used to "
"search for an item in a dictionary. Assume we want to search for the data"
" item ``33``. The computed hash value will be 2. Looking at slot 2 "
"reveals ``33``, at this point, we return ``True``. Searching for ``70`` "
"is quite different as there was a collision at the time of insertion. "
"Therefore computing the hash value is ``0`` which is currently holding "
"``44``. Instead of simply returning ``False``, we perform a sequential "
"search starting at point ``1`` until the item ``70`` is found or we "
"encounter a free slot. This is the general way of performing look-ups in "
"hashes:"
msgstr ""
"在字典中搜索项也是使用同样的方法，即开放寻址和线性探测。假设我们想搜索数据项 ``33`` 。"
"计算出的哈希值将是 2 。查看槽 2 会显示 ``33`` ，此时，我们返回 ``True`` 。"
"搜索 ``70`` 则展现出非常不同的过程，因为在插入时发生了冲突。"
"因为计算出的哈希值是 ``0`` ，它当前正在保存着 ``44`` 。"
"不过，此时我们并不是直接返回 ``False`` ，而是执行一个顺序搜索，从点 ``1`` 开始，直到找到项目 ``70`` 或遇到一个空闲槽。"
"这是一个在哈希中执行搜索的寻常方式："

