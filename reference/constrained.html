
<!DOCTYPE html>

<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="lang:clipboard.copy" content="Copy to clipboard">
  <meta name="lang:clipboard.copied" content="Copied to clipboard">
  <meta name="lang:search.language" content="en">
  <meta name="lang:search.pipeline.stopwords" content="True">
  <meta name="lang:search.pipeline.trimmer" content="True">
  <meta name="lang:search.result.none" content="No matching documents">
  <meta name="lang:search.result.one" content="1 matching document">
  <meta name="lang:search.result.other" content="# matching documents">
  <meta name="lang:search.tokenizer" content="[\s\-]+">

  
    <link href="https://fonts.gstatic.com/" rel="preconnect" crossorigin>
    <link href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,500,700|Roboto:300,400,400i,700&display=fallback" rel="stylesheet">

    <style>
      body,
      input {
        font-family: "Roboto", "Helvetica Neue", Helvetica, Arial, sans-serif
      }

      code,
      kbd,
      pre {
        font-family: "Roboto Mono", "Courier New", Courier, monospace
      }
    </style>
  

  <link rel="stylesheet" href="../_static/stylesheets/application.css"/>
  <link rel="stylesheet" href="../_static/stylesheets/application-palette.css"/>
  <link rel="stylesheet" href="../_static/stylesheets/application-fixes.css"/>
  
  <link rel="stylesheet" href="../_static/fonts/material-icons.css"/>
  
  <meta name="theme-color" content="#2196f3">
  <script src="../_static/javascripts/modernizr.js"></script>
  
  
  
    <title>微处理器上的 MicroPython &#8212; MicroPython 1.18 文档</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/material.css" />
    <link rel="stylesheet" href="../_static/customstyle.css" type="text/css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="MicroPython 清单文件" href="manifest.html" />
    <link rel="prev" title="最大化 MicroPython 速度" href="speed_python.html" />
  
   

  </head>
  <body dir=ltr
        data-md-color-primary=blue data-md-color-accent=light-blue>
  
  <svg class="md-svg">
    <defs data-children-count="0">
      
      <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448" viewBox="0 0 416 448" id="__github"><path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg>
      
    </defs>
  </svg>
  
  <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer">
  <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search">
  <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
  <a href="#reference/constrained" tabindex="1" class="md-skip"> Skip to content </a>
  <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex navheader">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="../index.html" title="MicroPython 1.18 文档"
           class="md-header-nav__button md-logo">
          
              <img src="../_static/Mlogo_138wh.png" height="26"
                   alt="MicroPython 1.18 文档 logo">
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          <span class="md-header-nav__topic">MicroPython 1.18 文档</span>
          <span class="md-header-nav__topic"> 微处理器上的 MicroPython </span>
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
        
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" action="../search.html" method="get" name="search">
      <input type="text" class="md-search__input" name="q" placeholder="Search"
             autocapitalize="off" autocomplete="off" spellcheck="false"
             data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>

      </div>
      
      
  
  <script src="../_static/javascripts/version_dropdown.js"></script>
  <script>
    var json_loc = "../"versions.json"",
        target_loc = "../../",
        text = "Versions";
    $( document ).ready( add_version_dropdown(json_loc, target_loc, text));
  </script>
  

    </div>
  </nav>
</header>

  
  <div class="md-container">
    
    
    
  <nav class="md-tabs" data-md-component="tabs">
    <div class="md-tabs__inner md-grid">
      <ul class="md-tabs__list">
          <li class="md-tabs__item"><a href="../index.html" class="md-tabs__link">MicroPython 1.18 文档</a></li>
          <li class="md-tabs__item"><a href="index.html" class="md-tabs__link">MicroPython 语言与实现</a></li>
      </ul>
    </div>
  </nav>
    <main class="md-main">
      <div class="md-main__inner md-grid" data-md-component="container">
        
          <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
            <div class="md-sidebar__scrollwrap">
              <div class="md-sidebar__inner">
                <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="../index.html" title="MicroPython 1.18 文档" class="md-nav__button md-logo">
      
        <img src="../_static/Mlogo_138wh.png" alt=" logo" width="48" height="48">
      
    </a>
    <a href="../index.html"
       title="MicroPython 1.18 文档">MicroPython 1.18 文档</a>
  </label>
  

  
  <ul class="md-nav__list">
    <li class="md-nav__item">
    
    
      <a href="../library/index.html" class="md-nav__link">MicroPython 库</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="index.html" class="md-nav__link">MicroPython 语言与实现</a>
      <ul class="md-nav__list"> 
    <li class="md-nav__item">
    
    
      <a href="glossary.html" class="md-nav__link">词汇表</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="repl.html" class="md-nav__link">MicroPython 交互式解释器模式 （又名 REPL）</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="mpremote.html" class="md-nav__link">MicroPython 远程控制: mpremote</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="mpyfiles.html" class="md-nav__link">MicroPython .mpy 文件</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="isr_rules.html" class="md-nav__link">编写中断处理程序</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="speed_python.html" class="md-nav__link">最大化 MicroPython 速度</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    <label class="md-nav__link md-nav__link--active" for="__toc"> 微处理器上的 MicroPython </label>
    
      <a href="#" class="md-nav__link md-nav__link--active">微处理器上的 MicroPython</a>
      
        
<nav class="md-nav md-nav--secondary">
    <label class="md-nav__title" for="__toc">Contents</label>
  <ul class="md-nav__list" data-md-scrollfix="">
        <li class="md-nav__item"><a href="#reference-constrained--page-root" class="md-nav__link">微处理器上的 MicroPython</a><nav class="md-nav">
              <ul class="md-nav__list">
        <li class="md-nav__item"><a href="#flash-memory" class="md-nav__link">闪存（ Flash memory ）</a>
        </li>
        <li class="md-nav__item"><a href="#ram" class="md-nav__link">RAM</a><nav class="md-nav">
              <ul class="md-nav__list">
        <li class="md-nav__item"><a href="#compilation-phase" class="md-nav__link">编译阶段</a>
        </li>
        <li class="md-nav__item"><a href="#execution-phase" class="md-nav__link">执行阶段</a>
        </li></ul>
            </nav>
        </li>
        <li class="md-nav__item"><a href="#the-heap" class="md-nav__link">堆</a><nav class="md-nav">
              <ul class="md-nav__list">
        <li class="md-nav__item"><a href="#fragmentation" class="md-nav__link">碎片化</a>
        </li>
        <li class="md-nav__item"><a href="#reporting" class="md-nav__link">报告</a>
        </li>
        <li class="md-nav__item"><a href="#control-of-garbage-collection" class="md-nav__link">控制垃圾回收</a>
        </li></ul>
            </nav>
        </li>
        <li class="md-nav__item"><a href="#string-operations" class="md-nav__link">字符串操作</a>
        </li>
        <li class="md-nav__item"><a href="#postscript" class="md-nav__link">Postscript</a><nav class="md-nav">
              <ul class="md-nav__list">
        <li class="md-nav__item"><a href="#footnote-gc-collect-return-value" class="md-nav__link">注释： gc.collect() 返回值</a>
        </li></ul>
            </nav>
        </li></ul>
            </nav>
        </li>
  </ul>
</nav>
      <ul class="md-nav__list"> 
    <li class="md-nav__item">
    
    
      <a href="#flash-memory" class="md-nav__link">闪存（ Flash memory ）</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="#ram" class="md-nav__link">RAM</a>
      <ul class="md-nav__list"> 
    <li class="md-nav__item">
    
    
      <a href="#compilation-phase" class="md-nav__link">编译阶段</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="#execution-phase" class="md-nav__link">执行阶段</a>
      
    
    </li></ul>
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="#the-heap" class="md-nav__link">堆</a>
      <ul class="md-nav__list"> 
    <li class="md-nav__item">
    
    
      <a href="#fragmentation" class="md-nav__link">碎片化</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="#reporting" class="md-nav__link">报告</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="#control-of-garbage-collection" class="md-nav__link">控制垃圾回收</a>
      
    
    </li></ul>
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="#string-operations" class="md-nav__link">字符串操作</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="#postscript" class="md-nav__link">Postscript</a>
      <ul class="md-nav__list"> 
    <li class="md-nav__item">
    
    
      <a href="#footnote-gc-collect-return-value" class="md-nav__link">注释： gc.collect() 返回值</a>
      
    
    </li></ul>
    
    </li></ul>
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="manifest.html" class="md-nav__link">MicroPython 清单文件</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="packages.html" class="md-nav__link">分发包、包管理和部署应用程序</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="asm_thumb2_index.html" class="md-nav__link">Inline assembler for Thumb2 architectures</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="filesystem.html" class="md-nav__link">Working with filesystems</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="pyboard.py.html" class="md-nav__link">The pyboard.py tool</a>
      
    
    </li></ul>
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../genrst/index.html" class="md-nav__link">MicroPython differences from CPython</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../develop/index.html" class="md-nav__link">MicroPython 内部实现</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../license.html" class="md-nav__link">MicroPython 开源协议信息</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../pyboard/quickref.html" class="md-nav__link">Quick reference for the pyboard</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../esp8266/quickref.html" class="md-nav__link">Quick reference for the ESP8266</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../esp32/quickref.html" class="md-nav__link">Quick reference for the ESP32</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../rp2/quickref.html" class="md-nav__link">Quick reference for the RP2</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../wipy/quickref.html" class="md-nav__link">Quick reference for the WiPy</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../unix/quickref.html" class="md-nav__link">Quick reference for the UNIX and Windows ports</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../zephyr/quickref.html" class="md-nav__link">Zephyr 适配的快速参考</a>
      
    
    </li>
  </ul>
  

</nav>
              </div>
            </div>
          </div>
          <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
            <div class="md-sidebar__scrollwrap">
              <div class="md-sidebar__inner">
                
<nav class="md-nav md-nav--secondary">
    <label class="md-nav__title" for="__toc">Contents</label>
  <ul class="md-nav__list" data-md-scrollfix="">
        <li class="md-nav__item"><a href="#reference-constrained--page-root" class="md-nav__link">微处理器上的 MicroPython</a><nav class="md-nav">
              <ul class="md-nav__list">
        <li class="md-nav__item"><a href="#flash-memory" class="md-nav__link">闪存（ Flash memory ）</a>
        </li>
        <li class="md-nav__item"><a href="#ram" class="md-nav__link">RAM</a><nav class="md-nav">
              <ul class="md-nav__list">
        <li class="md-nav__item"><a href="#compilation-phase" class="md-nav__link">编译阶段</a>
        </li>
        <li class="md-nav__item"><a href="#execution-phase" class="md-nav__link">执行阶段</a>
        </li></ul>
            </nav>
        </li>
        <li class="md-nav__item"><a href="#the-heap" class="md-nav__link">堆</a><nav class="md-nav">
              <ul class="md-nav__list">
        <li class="md-nav__item"><a href="#fragmentation" class="md-nav__link">碎片化</a>
        </li>
        <li class="md-nav__item"><a href="#reporting" class="md-nav__link">报告</a>
        </li>
        <li class="md-nav__item"><a href="#control-of-garbage-collection" class="md-nav__link">控制垃圾回收</a>
        </li></ul>
            </nav>
        </li>
        <li class="md-nav__item"><a href="#string-operations" class="md-nav__link">字符串操作</a>
        </li>
        <li class="md-nav__item"><a href="#postscript" class="md-nav__link">Postscript</a><nav class="md-nav">
              <ul class="md-nav__list">
        <li class="md-nav__item"><a href="#footnote-gc-collect-return-value" class="md-nav__link">注释： gc.collect() 返回值</a>
        </li></ul>
            </nav>
        </li></ul>
            </nav>
        </li>
  </ul>
</nav>
              </div>
            </div>
          </div>
        
        <div class="md-content">
          <article class="md-content__inner md-typeset" role="main">
            
  <section id="micropython-on-microcontrollers">
<span id="constrained"></span><h1 id="reference-constrained--page-root">微处理器上的 MicroPython<a class="headerlink" href="#reference-constrained--page-root" title="此标题的永久链接">¶</a></h1>
<p>MicroPython 旨在能够在微处理器上运行。这些处理器具有硬件限制，这对于更熟悉传统计算机的程序员来说可能是较为陌生的。特别是 RAM 和非易失性“磁盘”（闪存）存储的数量是有限的。本教程提供了充分利用有限资源的方法。因为 MicroPython 在基于各种架构的控制器上运行，所以提供的方法在大部分情况下是通用的：但在某些情况下，需要从特定于平台的文档中获取详细信息。</p>
<section id="flash-memory">
<h2 id="flash-memory">闪存（ Flash memory ）<a class="headerlink" href="#flash-memory" title="此标题的永久链接">¶</a></h2>
<p>在 Pyboard 上，解决容量有限的简单方法是安装 micro SD 卡。在某些情况下，这是不切实际的，要么是因为设备没有 SD 卡插槽，要么是出于成本或功耗的原因；因此必须使用板载 flash 。包含 MicroPython 子系统的固件存储在板载 flash 中。除固件外的剩余容量可供使用。由于与 flash 的物理架构有关的原因，此容量的一部分可能无法作为文件系统访问。在这种情况下，可以通过将用户模块合并到固件构建中来使用该空间，然后将其闪存到设备中。</p>
<p>有两种方法可以实现这一点：冻结模块和冻结字节码。冻结的模块将 Python 源代码与固件一起存储。冻结字节码使用交叉编译器将源代码转换为字节码，然后与固件一起存储。在上述任何一种方式中，都可以使用 import 语句访问模块：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">mymodule</span>
</pre></div>
</div>
<p>生成冻结模块和字节码的过程取决于平台；可以在源代码树相关部分的 README 文件中找到构建固件的说明。</p>
<p>一般情况下，步骤如下：</p>
<ul class="simple">
<li><p>克隆 MicroPython <a class="reference external" href="https://github.com/micropython/micropython">代码仓库</a> 。</p></li>
<li><p>获取（特定于平台的）工具链来构建固件。</p></li>
<li><p>构建交叉编译器。</p></li>
<li><p>将要冻结的模块放在指定的目录（取决于是将模块冻结为源代码，或字节码）。</p></li>
<li><p>构建固件。构建任一类型的冻结代码可能需要特定命令 - 请参阅平台文档。</p></li>
<li><p>将固件刷入设备。</p></li>
</ul>
</section>
<section id="ram">
<h2 id="ram">RAM<a class="headerlink" href="#ram" title="此标题的永久链接">¶</a></h2>
<p>要减少 RAM 使用时，需要考虑两个阶段：编译和执行。除了内存消耗之外，还有一个我们称之为堆碎片的问题。一般来说，最好尽量减少对象的重复创建和销毁。其原因在 <a class="reference external" href="#heap">堆</a> 的部分中进行了介绍。</p>
<section id="compilation-phase">
<h3 id="compilation-phase">编译阶段<a class="headerlink" href="#compilation-phase" title="此标题的永久链接">¶</a></h3>
<p>导入模块时， MicroPython 将代码编译为字节码，然后由 MicroPython 虚拟机 (VM) 执行。字节码存储在 RAM 中。编译器本身需要 RAM ，但在编译完成后即可使用。</p>
<p>如果已经导入了多个模块，则可能会出现 RAM 不足以运行编译器的情况。在这种情况下， import 语句将抛出内存异常。</p>
<p>如果一个模块在导入时实例化全局对象，它将在导入时就消耗 RAM ，然后编译器无法在后续导入时使用这些 RAM 。一般来说，最好避免在导入时运行的代码；更好的方法是在导入所有模块后让应用程序运行初始化代码。这使编译器可用的 RAM 最大化。</p>
<p>如果 RAM 仍然不足以编译所有模块，一种解决方案是预编译模块。 MicroPython 有一个交叉编译器，能够将 Python 模块编译为字节码（请参阅 mpy-cross 目录中的 README 文件）。生成的字节码文件具有 .mpy 扩展名；它可以被复制到文件系统并以一般形式导入（即 import 语句）。或者，部分或全部模块可以实现为冻结字节码：在大多数平台上，这可以节省更多 RAM ，因为字节码直接从闪存运行，而无需存储在 RAM 中。</p>
</section>
<section id="execution-phase">
<h3 id="execution-phase">执行阶段<a class="headerlink" href="#execution-phase" title="此标题的永久链接">¶</a></h3>
<p>有一些写代码的技巧可以减少 RAM 占用。</p>
<p><strong>常量</strong></p>
<p>MicroPython 提供了 <code class="docutils literal notranslate"><span class="pre">const</span></code> 关键字，可以这样使用：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">micropython</span> <span class="k">import</span> <span class="n">const</span>
<span class="n">ROWS</span> <span class="o">=</span> <span class="n">const</span><span class="p">(</span><span class="mi">33</span><span class="p">)</span>
<span class="n">_COLS</span> <span class="o">=</span> <span class="n">const</span><span class="p">(</span><span class="mh">0x10</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">ROWS</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">_COLS</span>
</pre></div>
</div>
<p>在将常量分配给变量的两种情况下，编译器都会通过替换常量的字面值来避免对常量名称的查找进行编码。这可以节省字节码，从而节省 RAM 。然而， <code class="docutils literal notranslate"><span class="pre">ROWS</span></code> 值将占用至少两个机器字，分别用于全局字典中的键和值。它在字典中的存在是必要的，因为另一个模块可能会导入或使用它。可以通过在名称前加上下划线来保存此 RAM ，如上例中的 <code class="docutils literal notranslate"><span class="pre">_COLS</span></code> ：此符号在模块外部不可见，因此不会占用 RAM。</p>
<p><code class="docutils literal notranslate"><span class="pre">const()</span></code> 的参数可以是在编译​​时计算为整数的任何值，例如 <code class="docutils literal notranslate"><span class="pre">0x100</span></code> 或 <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">&lt;&lt;</span> <span class="pre">8</span></code> 。它甚至可以包含其他已定义的 const 符号，例如 <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">&lt;&lt;</span> <span class="pre">BIT</span></code> 。</p>
<p><strong>常量数据结构</strong></p>
<p>在有大量常量数据且平台支持从 Flash 执行的情况下， RAM 可以按如下方式保存。数据应位于 Python 模块中并冻结为字节码。数据必须定义为 <a class="reference internal" href="../library/builtins.html#bytes" title="bytes"><code class="xref any py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 对象。编译器“知道” <a class="reference internal" href="../library/builtins.html#bytes" title="bytes"><code class="xref any py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 对象是不可变的，并确保对象保留在 Flash 中而不是被复制到 RAM 中。 <a class="reference internal" href="../library/struct.html#module-struct" title="struct: pack and unpack primitive data types"><code class="xref any py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a> 模块有助于数据在 <a class="reference internal" href="../library/builtins.html#bytes" title="bytes"><code class="xref any py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 类型和其他 Python 内置类型之间进行转换。</p>
<p>在考虑冻结字节码的影响时，请注意在 Python 字符串中，浮点数、字节、整数和复数是不可变的。因此，这些将被冻结到 flash 中。因此，在此行中</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mystring</span> <span class="o">=</span> <span class="s2">"The quick brown fox"</span>
</pre></div>
</div>
<p>实际的字符串 “The quick brown fox” 将驻留在闪存中。在运行时，对字符串的引用被分配给 <em>变量</em> <code class="docutils literal notranslate"><span class="pre">mystring</span></code> 。该引用占用一个机器字。原则上长整数也可以作为常量数据存储：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">bar</span> <span class="o">=</span> <span class="mh">0xDEADBEEF0000DEADBEEF</span>
</pre></div>
</div>
<p>与字符串示例一样，在运行时将任意大整数的引用分配给变量 <code class="docutils literal notranslate"><span class="pre">bar</span></code> 。该引用占用一个机器字。</p>
<p>据此，似乎可以预估整数元组能以最少的 RAM 占用作为常量数据存储。但对于当前的编译器，这是无效的（代码有效，但没有节省 RAM ）。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">foo</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">100000</span><span class="p">)</span>
</pre></div>
</div>
<p>在运行时，元组将位于 RAM 中。这一行为可能会在未来改进。</p>
<p><strong>无需创建对象</strong></p>
<p>在许多情况下，对象可能会在不经意间被创建和销毁。这会导致碎片化，而后降低 RAM 的可用性。以下部分讨论了这方面的实例。</p>
<p><strong>字符串连接</strong></p>
<p>假设以下代码片段，以生成常量字符串：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="o">=</span> <span class="s2">"foo"</span> <span class="o">+</span> <span class="s2">"bar"</span>
<span class="n">var1</span> <span class="o">=</span> <span class="s2">"foo"</span> <span class="s2">"bar"</span>
<span class="n">var2</span> <span class="o">=</span> <span class="s2">"""</span><span class="se">\</span>
<span class="s2">foo</span><span class="se">\</span>
<span class="s2">bar"""</span>
</pre></div>
</div>
<p>其中每一句的效果都相同，但是第一个在运行时不必要地创建了两个字符串对象，在产生结果之前导致分配更多的 RAM 用于连接。其他语句则在编译时执行连接，效率更高，减少了碎片化。</p>
<p>在将字符串输入到诸如文件之类的流之前，必须动态创建字符串，如果以逐个传入的方式完成，它将节省 RAM 。与其创建一个大字符串对象，不如创建一个子字符串并将其提供给流，然后再处理下一个。</p>
<p>创建动态字符串的最佳方法，是使用字符串 <code class="docutils literal notranslate"><span class="pre">format()</span></code> 方法：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="o">=</span> <span class="s2">"Temperature </span><span class="si">{:5.2f}</span><span class="s2"> Pressure </span><span class="si">{:06d}</span><span class="se">\n</span><span class="s2">"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">press</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>缓冲区</strong></p>
<p>在访问 UART、I2C 和 SPI 接口之类的设备实例时，使用预分配缓冲区可避免创建不必要的对象。假设在这两个循环中：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="n">var</span> <span class="o">=</span> <span class="n">spi</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
    <span class="c1"># process data</span>

<span class="n">buf</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="n">spi</span><span class="o">.</span><span class="n">readinto</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
    <span class="c1"># process data in buf</span>
</pre></div>
</div>
<p>第一个在每次传递时创建一个缓冲区，而第二个重新使用预先分配的缓冲区；就考虑内存碎片问题而言，后者既更快又更高效。</p>
<p><strong>字节比整数小</strong></p>
<p>在大多数平台上，一个整数占用四个字节。假设在这两个 <code class="docutils literal notranslate"><span class="pre">foo()</span></code> 调用中：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">bar</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">bar</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">foo</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">))</span>
<span class="n">foo</span><span class="p">(</span><span class="sa">b</span><span class="s1">'</span><span class="se">\1\2\xff</span><span class="s1">'</span><span class="p">)</span>
</pre></div>
</div>
<p>在第一个调用中，在 RAM 中创建了一个整数元组。第二个则有效地创建了一个消耗最少 RAM 的 <a class="reference internal" href="../library/builtins.html#bytes" title="bytes"><code class="xref any py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 对象。如果模块被冻结为字节码， <a class="reference internal" href="../library/builtins.html#bytes" title="bytes"><code class="xref any py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 对象将驻留在闪存中。</p>
<p><strong>字符串 VS 字节</strong></p>
<p>Python3 引入了 Unicode 支持。这引入了字符串和字节数组之间的区别。只要 Unicode 字符串中的所有字符都是 ASCII 码（即值 &lt; 126 ）， MicroPython 确保其字符串无需占用额外空间。如果需要完整 8 位范围内的值，则可以使用 <a class="reference internal" href="../library/builtins.html#bytes" title="bytes"><code class="xref any py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 和 <a class="reference internal" href="../library/builtins.html#bytearray" title="bytearray"><code class="xref any py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 对象来确保不需要额外的空间。请注意，大多数字符串方法（例如 <a class="reference external" href="https://docs.python.org/3.5/library/stdtypes.html#str.strip" title="（在 Python v3.5）"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.strip()</span></code></a> ）也适用于 <a class="reference internal" href="../library/builtins.html#bytes" title="bytes"><code class="xref any py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 实例，因此消除 Unicode 的过程可以很轻松。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="s1">'the quick brown fox'</span>   <span class="c1"># A string instance</span>
<span class="n">b</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">'the quick brown fox'</span>  <span class="c1"># A bytes instance</span>
</pre></div>
</div>
<p>如果需要在字符串和 bytes 之间进行转换，可以使用 <a class="reference external" href="https://docs.python.org/3.5/library/stdtypes.html#str.encode" title="（在 Python v3.5）"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.encode()</span></code></a> 和 <a class="reference external" href="https://docs.python.org/3.5/library/stdtypes.html#bytes.decode" title="（在 Python v3.5）"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytes.decode()</span></code></a> 方法。请注意，字符串和 bytes 都是不可变的。任何将这样一个对象作为输入并产生另一个对象的操作，都意味着至少分配一个 RAM 来产生结果。在下面的第二行中，分配了一个新的字节对象。如果 <code class="docutils literal notranslate"><span class="pre">foo</span></code> 是一个字符串，也会发生这种情况。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">foo</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">'   empty whitespace'</span>
<span class="n">foo</span> <span class="o">=</span> <span class="n">foo</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span>
</pre></div>
</div>
<p><strong>运行时编译器执行</strong></p>
<p>Python 函数 <a class="reference internal" href="../library/builtins.html#eval" title="eval"><code class="xref any py py-func docutils literal notranslate"><span class="pre">eval</span></code></a> 和 <a class="reference internal" href="../library/builtins.html#exec" title="exec"><code class="xref any py py-func docutils literal notranslate"><span class="pre">exec</span></code></a> 在运行时调用编译器，这需要大量 RAM 。请注意，来自 <a class="reference internal" href="glossary.html#term-micropython-lib"><code class="xref any std std-term docutils literal notranslate"><span class="pre">micropython-lib</span></code></a> 的 <code class="docutils literal notranslate"><span class="pre">pickle</span></code> 库使用 <a class="reference internal" href="../library/builtins.html#exec" title="exec"><code class="xref any py py-func docutils literal notranslate"><span class="pre">exec</span></code></a> 。使用 <a class="reference internal" href="../library/json.html#module-json" title="json: JSON encoding and decoding"><code class="xref any py py-mod docutils literal notranslate"><span class="pre">json</span></code></a> 库进行对象序列化可能会提高 RAM 效率。</p>
<p><strong>存储字符串到 flash 中</strong></p>
<p>Python 字符串是不可变的，因此有可能存储在只读内存中。编译器可以放置在 Python 代码中定义的 flash 字符串中。与冻结模块一样，需要在 PC 上拥有源代码树的副本以及构建固件的工具链。即使模块尚未完全调试通过，该过程也将起作用，只要它们可以导入和运行。</p>
<p>导入模块后，执行：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">micropython</span><span class="o">.</span><span class="n">qstr_info</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>然后将所有 Q(xxx) 行复制并粘贴到文本编辑器中。检查并删除明显无效的行。打开文件 qstrdefsport.h ，该文件位于 ports/stm32 （或你所用架构的等效目录）中。将更正的行复制并粘贴到文件末尾。保存文件，重新构建并烧录固件。可以通过导入模块，然后再次执行函数检查结果：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">micropython</span><span class="o">.</span><span class="n">qstr_info</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>此时 Q(xxx) 对应的行应该被删除了。</p>
</section>
</section>
<section id="the-heap">
<span id="heap"></span><h2 id="the-heap">堆<a class="headerlink" href="#the-heap" title="此标题的永久链接">¶</a></h2>
<p>当正在运行的程序实例化一个对象时，必要的 RAM 是从固定大小的池中分配的，该池我们称之为堆。当超出对象的作用域（换句话说，代码无法访问）时，冗余对象被称为“垃圾”。一个称为“垃圾回收”（ GC ）的进程回收该内存，将这一内存返回到空闲堆。这个过程自动运行，但是它可以通过直接调用 <a class="reference internal" href="../library/gc.html#gc.collect" title="gc.collect"><code class="xref any py py-func docutils literal notranslate"><span class="pre">gc.collect()</span></code></a> 手动触发。</p>
<p>这方面的论述有些复杂难懂。出于更“快速解决”问题的角度而言，请定期执行以下操作：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
<span class="n">gc</span><span class="o">.</span><span class="n">threshold</span><span class="p">(</span><span class="n">gc</span><span class="o">.</span><span class="n">mem_free</span><span class="p">()</span> <span class="o">//</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">gc</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">())</span>
</pre></div>
</div>
<section id="fragmentation">
<h3 id="fragmentation">碎片化<a class="headerlink" href="#fragmentation" title="此标题的永久链接">¶</a></h3>
<p>假设一个程序创建了一个对象 <code class="docutils literal notranslate"><span class="pre">foo</span></code> ，然后创建了一个对象 <code class="docutils literal notranslate"><span class="pre">bar</span></code> 。随后 <code class="docutils literal notranslate"><span class="pre">foo</span></code> 超出作用域，但 <code class="docutils literal notranslate"><span class="pre">bar</span></code> 仍然存在。此时 <code class="docutils literal notranslate"><span class="pre">foo</span></code> 使用的 RAM 将被 GC 回收。然而，如果 <code class="docutils literal notranslate"><span class="pre">bar</span></code> 被分配到更高的地址，则从 <code class="docutils literal notranslate"><span class="pre">foo</span></code> 回收的 RAM 将仅适用于分配给不大于 <code class="docutils literal notranslate"><span class="pre">foo</span></code> 的对象。在复杂或长时间运行的程序中，堆可能会变得碎片化，这将导致：尽管有大量可用 RAM ，但没有足够的连续空间来分配特定对象，并且程序会抛出内存错误而失败。</p>
<p>上述技术旨在最大限度地减少这种情况。在需要大型永久缓冲区或其他对象的情况下，最好在程序执行过程的早期，即出现碎片化之前，实例化它们。可以通过监控堆的状态和控制 GC 来做进一步的改进；这些方式将在下文进行阐述。</p>
</section>
<section id="reporting">
<h3 id="reporting">报告<a class="headerlink" href="#reporting" title="此标题的永久链接">¶</a></h3>
<p>MicroPython 中包含许多库函数可用于报告内存分配和控制 GC 。这些函数可以在 <a class="reference internal" href="../library/gc.html#module-gc" title="gc: control the garbage collector"><code class="xref any py py-mod docutils literal notranslate"><span class="pre">gc</span></code></a> 和 <a class="reference internal" href="../library/micropython.html#module-micropython" title="micropython: access and control MicroPython internals"><code class="xref any py py-mod docutils literal notranslate"><span class="pre">micropython</span></code></a> 模块中找到。以下示例可以粘贴到 REPL 中执行（先按下 <code class="docutils literal notranslate"><span class="pre">ctrl</span> <span class="pre">e</span></code> 进入粘贴模式，然后通过 <code class="docutils literal notranslate"><span class="pre">ctrl</span> <span class="pre">d</span></code> 运行它）。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">gc</span>
<span class="kn">import</span> <span class="nn">micropython</span>
<span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
<span class="n">micropython</span><span class="o">.</span><span class="n">mem_info</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">'-----------------------------'</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">'Initial free: </span><span class="si">{}</span><span class="s1"> allocated: </span><span class="si">{}</span><span class="s1">'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">gc</span><span class="o">.</span><span class="n">mem_free</span><span class="p">(),</span> <span class="n">gc</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">()))</span>
<span class="k">def</span> <span class="nf">func</span><span class="p">():</span>
    <span class="n">a</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span>
<span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">'Func definition: </span><span class="si">{}</span><span class="s1"> allocated: </span><span class="si">{}</span><span class="s1">'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">gc</span><span class="o">.</span><span class="n">mem_free</span><span class="p">(),</span> <span class="n">gc</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">()))</span>
<span class="n">func</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">'Func run free: </span><span class="si">{}</span><span class="s1"> allocated: </span><span class="si">{}</span><span class="s1">'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">gc</span><span class="o">.</span><span class="n">mem_free</span><span class="p">(),</span> <span class="n">gc</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">()))</span>
<span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">'Garbage collect free: </span><span class="si">{}</span><span class="s1"> allocated: </span><span class="si">{}</span><span class="s1">'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">gc</span><span class="o">.</span><span class="n">mem_free</span><span class="p">(),</span> <span class="n">gc</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">()))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">'-----------------------------'</span><span class="p">)</span>
<span class="n">micropython</span><span class="o">.</span><span class="n">mem_info</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>以上方法使用：</p>
<ul class="simple">
<li><p><a class="reference internal" href="../library/gc.html#gc.collect" title="gc.collect"><code class="xref any py py-func docutils literal notranslate"><span class="pre">gc.collect()</span></code></a> 强制触发一次垃圾回收。返回值可参阅注释</p></li>
<li><p><a class="reference internal" href="../library/micropython.html#micropython.mem_info" title="micropython.mem_info"><code class="xref any py py-func docutils literal notranslate"><span class="pre">micropython.mem_info()</span></code></a> 打印当前 RAM 利用率的概览</p></li>
<li><p><a class="reference internal" href="../library/gc.html#gc.mem_free" title="gc.mem_free"><code class="xref any py py-func docutils literal notranslate"><span class="pre">gc.mem_free()</span></code></a> 返回当前空闲堆大小（以字节为单位）</p></li>
<li><p><a class="reference internal" href="../library/gc.html#gc.mem_alloc" title="gc.mem_alloc"><code class="xref any py py-func docutils literal notranslate"><span class="pre">gc.mem_alloc()</span></code></a> 返回当前已分配的字节数</p></li>
<li><p><code class="xref any docutils literal notranslate"><span class="pre">micropython.mem_info(1)</span></code> 打印堆利用率的详细信息表（详见下文）</p></li>
</ul>
<p>这里生成的数字取决于平台，但可以看出，声明函数使用了少量 RAM ，基于编译器发出的字节码形式（编译器使用的 RAM 已被回收）。运行该函数使用超过 10KiB 的内存，但在返回时 a 已经是垃圾，因为它超出作用并且无法引用。最后，调用 <a class="reference internal" href="../library/gc.html#gc.collect" title="gc.collect"><code class="xref any py py-func docutils literal notranslate"><span class="pre">gc.collect()</span></code></a> 恢复该内存。</p>
<p><code class="docutils literal notranslate"><span class="pre">micropython.mem_info(1)</span></code> 产生的最终输出可能在细节上有所不同，但基本如下：</p>
<table>
<thead>
<tr class="row-odd"><th class="head"><p>符号</p></th>
<th class="head"><p>含义</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>.</p></td>
<td><p>空闲块</p></td>
</tr>
<tr class="row-odd"><td><p>h</p></td>
<td><p>头部块</p></td>
</tr>
<tr class="row-even"><td><p>=</p></td>
<td><p>尾部块</p></td>
</tr>
<tr class="row-odd"><td><p>m</p></td>
<td><p>标记的头部块</p></td>
</tr>
<tr class="row-even"><td><p>T</p></td>
<td><p>元组</p></td>
</tr>
<tr class="row-odd"><td><p>L</p></td>
<td><p>列表</p></td>
</tr>
<tr class="row-even"><td><p>D</p></td>
<td><p>字典</p></td>
</tr>
<tr class="row-odd"><td><p>F</p></td>
<td><p>浮点</p></td>
</tr>
<tr class="row-even"><td><p>B</p></td>
<td><p>字节码</p></td>
</tr>
<tr class="row-odd"><td><p>M</p></td>
<td><p>模块</p></td>
</tr>
</tbody>
</table>
<p>每个字母代表一个内存块，一个块为 16 个字节。所以堆转储的每一行代表 0x400 字节或 1KiB 的 RAM 。</p>
</section>
<section id="control-of-garbage-collection">
<h3 id="control-of-garbage-collection">控制垃圾回收<a class="headerlink" href="#control-of-garbage-collection" title="此标题的永久链接">¶</a></h3>
<p>可以通过发出 <a class="reference internal" href="../library/gc.html#gc.collect" title="gc.collect"><code class="xref any py py-func docutils literal notranslate"><span class="pre">gc.collect()</span></code></a> 随时触发 GC 。每隔一段时间这样做是有益的，首先是为了预防碎片化，其次是为了提高性能。 GC 可能需要几毫秒，但在几乎没有工作要做的情况下会更快（在 Pyboard 上大约只需 1 毫秒）。显式调用垃圾回收可以最大限度地减少延迟，同时确保它在程序中可接受的时机发生。</p>
<p>在这些情况下会引发自动 GC ：首先，当尝试分配失败时，将执行 GC 并重新尝试分配。仅当此操作失败时才会引发异常。其次，如果可用 RAM 量低于阈值，将触发自动 GC。这个阈值可以通过以下方式，在执行过程中进行调整：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
<span class="n">gc</span><span class="o">.</span><span class="n">threshold</span><span class="p">(</span><span class="n">gc</span><span class="o">.</span><span class="n">mem_free</span><span class="p">()</span> <span class="o">//</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">gc</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">())</span>
</pre></div>
</div>
<p>这段代码表示，如果当前空闲堆的 25% 以上被占用，将引发 GC 。</p>
<p>一般来说，模块应该在运行时使用构造函数或其他初始化函数来实例化数据对象。原因是如果在初始化时发生这种情况，编译器可能会在导入后续模块时不够 RAM 。如果模块确实在导入时实例化数据，那么在导入后调用 <a class="reference internal" href="../library/gc.html#gc.collect" title="gc.collect"><code class="xref any py py-func docutils literal notranslate"><span class="pre">gc.collect()</span></code></a> 将改善此问题。</p>
</section>
</section>
<section id="string-operations">
<h2 id="string-operations">字符串操作<a class="headerlink" href="#string-operations" title="此标题的永久链接">¶</a></h2>
<p>MicroPython 以高效的方式处理字符串，理解这一点有助于设计在微控制器上运行的应用程序。编译模块时，多次出现的字符串只存储一次，这个过程称为字符串驻留。在 MicroPython 中，驻留字符串称为 qstr 。在正常导入的模块中，单个实例将位于 RAM 中，但如上所述，在冻结为字节码的模块中，它将位于 flash 中。</p>
<p>字符串比较也可以使用 hash 高效执行，而不是逐个字符对比。因此，在性能和 RAM 使用方面，使用字符串而不是整数的代价可能很小 —— 这可能会让 C 程序员感到惊讶。</p>
</section>
<section id="postscript">
<h2 id="postscript">Postscript<a class="headerlink" href="#postscript" title="此标题的永久链接">¶</a></h2>
<p>MicroPython 通过 <em>引用</em> 传递、返回和（默认情况下）复制对象。一个引用只占用单个机器字，因此这些进程在 RAM 使用和速度方面非常有效。</p>
<p>在需要大小既不是字节也不是机器字的变量的地方，有标准库可以帮助有效地存储这些变量并执行转换。请参阅 <a class="reference internal" href="../library/array.html#module-array" title="array: efficient arrays of numeric data"><code class="xref any py py-mod docutils literal notranslate"><span class="pre">array</span></code></a> 、 <a class="reference internal" href="../library/struct.html#module-struct" title="struct: pack and unpack primitive data types"><code class="xref any py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a> 和 <a class="reference internal" href="../library/uctypes.html#module-uctypes" title="uctypes: access binary data in a structured way"><code class="xref any py py-mod docutils literal notranslate"><span class="pre">uctypes</span></code></a> 模块。</p>
<section id="footnote-gc-collect-return-value">
<h3 id="footnote-gc-collect-return-value">注释： gc.collect() 返回值<a class="headerlink" href="#footnote-gc-collect-return-value" title="此标题的永久链接">¶</a></h3>
<p>在 Unix 和 Windows 平台上， <a class="reference internal" href="../library/gc.html#gc.collect" title="gc.collect"><code class="xref any py py-func docutils literal notranslate"><span class="pre">gc.collect()</span></code></a> 方法将返回一个整数，表示在集合中回收的不同内存区域的数量（更准确地说，是变成空闲的头部块数量）。由于效率影响，裸机适配端不返回此值。</p>
</section>
</section>
</section>


          </article>
        </div>
      </div>
    </main>
  </div>
  <footer class="md-footer">
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
          
            <a href="speed_python.html" title="最大化 MicroPython 速度"
               class="md-flex md-footer-nav__link md-footer-nav__link--prev"
               rel="prev">
              <div class="md-flex__cell md-flex__cell--shrink">
                <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
              </div>
              <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
                <span class="md-flex__ellipsis">
                  <span
                      class="md-footer-nav__direction"> Previous </span> 最大化 MicroPython 速度 </span>
              </div>
            </a>
          
          
            <a href="manifest.html" title="MicroPython 清单文件"
               class="md-flex md-footer-nav__link md-footer-nav__link--next"
               rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title"><span
                class="md-flex__ellipsis"> <span
                class="md-footer-nav__direction"> Next </span> MicroPython 清单文件 </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink"><i
                class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          
        </a>
        
      </nav>
    </div>
    <div class="md-footer-meta md-typeset">
      <div class="md-footer-meta__inner md-grid">
        <div class="md-footer-copyright">
          <div class="md-footer-copyright__highlight">
              &#169; Copyright - The MicroPython Documentation is Copyright © 2014-2022, Damien P. George, Paul Sokolovsky, and contributors.
              
          </div>
            Last updated on
              11 8月 2022.
            <br/>
            Created using
            <a href="http://www.sphinx-doc.org/">Sphinx</a> 5.1.1.
             and
            <a href="https://github.com/bashtage/sphinx-material/">Material for
              Sphinx</a>
        </div>
      </div>
    </div>
  </footer>
  <script src="../_static/javascripts/application.js"></script>
  <script>app.initialize({version: "1.0.4", url: {base: ".."}})</script>
  </body>
</html>